<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DFX Console - v101 (Faster Concurrent Effects)</title> <!-- Title Updated -->
    <!-- GSAP Core -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <!-- GSAP TextPlugin -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/TextPlugin.min.js"></script>
    <!-- Material Symbols -->
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200" />
    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@400;500&family=Raleway:wght@600&display=swap" rel="stylesheet">
    <style>
  /* ==========================================================================
     1. Base Variables & Global Styles
     ========================================================================== */

  :root {
     /* --- Layout & Spacing --- */
     --semantic-space-xl: 1.5rem;
     --semantic-space-m: 1rem;
     --semantic-space-s-m: 0.75rem;
     --semantic-space-s: 0.5rem;
     --semantic-space-xs: 0.25rem;
     --header-controls-gap: var(--semantic-space-s-m);
     --panel-gap: 0rem;
     --master-panel-padding: 0.5rem;
     --line-width-thin: 0.0625rem;
     --line-width-thick: 0.125rem;
     --header-control-height: 2.625rem;
     --logo-height: 1.5rem;

     /* --- Slider Dimensions --- */
     --slider-track-height-default: 0.125rem;
     --slider-track-height-hover: 0.375rem;
     --slider-thumb-height: 2rem;
     --slider-thumb-width: 1.25rem;
     --slider-track-radius: 0.375rem;
     --slider-thumb-radius: 0.375rem;
     --header-button-height: 2rem;

     /* --- Radii --- */
     --semantic-radius-s: 0.25rem;
     --semantic-radius-sm: 0.375rem;
     --semantic-radius-m: 0.5rem;
     --semantic-radius-l: 1rem;
     --semantic-radius-lg: 1.5rem;
     --semantic-radius-xl: 2.5rem;
     --master-panel-radius: 3rem;

     /* --- Fonts --- */
     --font-headings: 'Raleway', sans-serif;
     --font-monospace: "IBM Plex Mono", monospace;
     --title-medium-font-size: 1.75rem;
     --label-medium-font-size: 1rem;
     --label-small-font-size: 0.75rem;
     --button-font-size: 0.8125rem;
     --value-font-size: 0.8125rem;
     --footer-font-size: 0.75rem;
     --title-font-weight: 600;
     --label-font-weight: 600;
     --button-font-weight: 600;
     --value-font-weight: 500;

     /* --- Transitions (Faster Special) --- */
     --transition-duration-fast: 0.1s;
     --transition-duration-medium: 0.2s;
     --transition-duration-slow: 0.3s;
     --transition-ease: ease;
     --transition-ease-out: ease-out;
     /* --- GSAP Specific Durations (Faster Special) --- */
     --gsap-slider-click-duration: 0.08s;
     --gsap-slider-icon-duration: 0.1s;
     --gsap-slider-icon-ease: 'power1.out';
     --gsap-slider-track-enter-duration: 0.1s;
     --gsap-slider-track-leave-duration: 0.1s;
     --gsap-slider-track-leave-ease: 'power2.out';

     /* --- Shadows --- */
     --control-shadow: 0rem 0.125rem 0.3125rem 0rem rgba(0, 0, 0, 0.15);
     --master-panel-shadow: 0px 8px 16px 0px rgba(0, 0, 0, 0.10), 0px 4px 8px 0px rgba(0, 0, 0, 0.10), 0px 2px 4px 0px rgba(0, 0, 0, 0.10);
     --slider-track-inset-shadow: inset 0rem 0.25rem 0.25rem 0rem rgba(0, 0, 0, 0.25);
     --slider-thumb-shadow: var(--control-shadow);

     /* --- Colors (Light Theme Defaults) --- */
     --body-text-color: oklch(0.15 0 0);
     --panel-border-color: oklch(0.89 0.02 255);
     --panel-bg-base: oklch(0.96 0.01 255);
     --panel-bg-elevated: oklch(1.00 0.00 0);
     --panel-bg-sunken: oklch(0.93 0.01 255);
     --panel-text-color: oklch(0.10 0.02 270);
     --panel-label-color: oklch(0.10 0.02 270);
     --secondary-text: oklch(0.34 0.1 255);
     --faint-control-text: oklch(0.5 0.03 255);
     --accent-color: oklch(0.51 0.08 255);
     --interactive-bg: oklch(0.30 0.036 255 / 0.06);
     --interactive-bg-hover: oklch(0.47 0.191 255 / 0.10);
     --interactive-bg-pressed: oklch(0.42 0.191 255 / 0.10);
     --toggle-active-shadow: var(--control-shadow);
     --toggle-active-text: oklch(0.07 0.1 0);
     --toggle-inactive-text: oklch(0.37 0.21 0);
     --button-active-bg: oklch(1 0 0);
     --dial-base-stroke: oklch(0.80 0 0);
     --console-text-color: #333333;
     --svg-bg-color: oklch(0.30 0.036 255 / 0.06);
     --dot-resting-color: #333333;
     --dot-hover-color: oklch(0.60 0.18 255);
     --dot-sleep-color: oklch(0.78 0.03 270);
     --grid-line-color: oklch(0.5 0.03 255 / 0.30);
     --hover-indicator-color: oklch(1 0 0);
     --slider-track-gradient: linear-gradient(90deg, grey, lightgrey);
     --theme-icon-light-fill: oklch(1 0 0);
     --theme-icon-light-stroke: oklch(0.80 0.01 255);
     --theme-icon-saturated-fill: oklch(0.7 0.25 var(--brand-hue));
     --theme-icon-saturated-stroke: oklch(0.80 0.05 var(--brand-hue));
     --theme-icon-dark-fill: oklch(0.27 0 0);
     --theme-icon-dark-stroke: oklch(0.50 0.02 255);
     --master-panel-border-color: rgba(255, 255, 255, 1);
     --master-panel-bg-color: rgba(255, 255, 255, 0.20);

     /* --- State Variables --- */
     --brand-hue: 255;
     --hue-slider-value-percent: 50%;
     --slider-thumb-icon-grad: -25;
     --slider-mask-height-factor: 1;
     --tap-icon-grad: -25;
 }

 /* --- Saturated Theme Overrides --- */
 body.saturated-theme-active {
    --body-text-color: oklch(0 0 0);
    --panel-text-color: oklch(0 0 0);
    --panel-label-color: oklch(0 0 0);
    --secondary-text: oklch(0.34 0.15 var(--brand-hue));
    --faint-control-text: oklch(0.5 0.09 var(--brand-hue));
    --toggle-active-text: oklch(0 0 0);
    --toggle-inactive-text: oklch(0.20 0 0);
    --dial-base-stroke: 'var(--panel-border-color)';
    --panel-bg-elevated: oklch(1.00 0.00 0);
 }

 /* --- Dark Theme Overrides --- */
 body.dark-theme {
     --body-text-color: oklch(0.88 0 0);
     --panel-border-color: oklch(0.55 0.02 var(--brand-hue));
     --panel-bg-base: oklch(0.22 0.01 var(--brand-hue));
     --panel-bg-elevated: oklch(0.15 0.005 var(--brand-hue));
     --panel-bg-sunken: oklch(0.15 0.00 var(--brand-hue));
     --panel-text-color: oklch(0.88 0 0);
     --panel-label-color: oklch(0.88 0 0);
     --secondary-text: oklch(0.9 0.05 var(--brand-hue));
     --faint-control-text: oklch(0.75 0.03 var(--brand-hue));
     --control-shadow: 0rem 0.125rem 0.3125rem 0rem rgba(0, 0, 0, 0.3);
     --toggle-active-shadow: var(--control-shadow);
     --toggle-active-text: oklch(1 0 0);
     --toggle-inactive-text: oklch(0.67 0 0);
     --button-active-bg: oklch(0.30 0.01 var(--brand-hue));
     --dial-base-stroke: oklch(0.33 0 0);
     --slider-thumb-shadow: var(--control-shadow);
     --body-bg-color: oklch(0 0 0);
 }

 /* ==========================================================================
    2. Base Element Styles
    ========================================================================== */
 body {
    margin: 0; padding: 0; display: flex; flex-direction: column; align-items: center; min-height: 100vh; background-color: var(--body-bg-color); color: var(--body-text-color); overflow-x: hidden; position: relative; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"; transition: background-color var(--transition-duration-slow) var(--transition-ease), color var(--transition-duration-slow) var(--transition-ease); -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale;
 }
 body::before {
    content: ""; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background-color: transparent; /* Note: Complex filters can impact performance */ filter: url(#noiseFilter); z-index: -1; pointer-events: none;
 }
 * {
    user-select: none; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; -webkit-tap-highlight-color: transparent; box-sizing: border-box;
 }
 body.dark-theme::before { filter: none; }

 /* ==========================================================================
    3. Layout Containers
    ========================================================================== */
 #main-content-area { margin-top: calc(4.375rem - var(--master-panel-padding)); display: flex; flex-direction: column; align-items: center; width: 100%; max-width: calc(34.375rem + 2 * var(--master-panel-padding)); padding: 0; }
 #master-panel-wrapper { width: 100%; padding: var(--master-panel-padding); border-radius: var(--master-panel-radius); border: 2px solid var(--master-panel-border-color); background: var(--master-panel-bg-color); box-shadow: var(--master-panel-shadow); transition: border-color var(--transition-duration-slow) var(--transition-ease), background-color var(--transition-duration-slow) var(--transition-ease); }
 #control-console-frame { display: flex; flex-direction: column; align-items: stretch; gap: var(--panel-gap); width: 100%; margin-bottom: 0; overflow: hidden; border-radius: var(--semantic-radius-xl); }

 /* ==========================================================================
    4. Section Panels
    ========================================================================== */
 #header-section { display: flex; padding: var(--semantic-space-xl) var(--semantic-space-m) var(--semantic-space-m); flex-direction: column; align-items: center; gap: var(--semantic-space-xl); align-self: stretch; border-radius: var(--semantic-radius-xl) var(--semantic-radius-xl) 0 0; border: 1px solid var(--panel-border-color); border-bottom: 1px solid var(--panel-border-color); background-color: var(--panel-bg-elevated); transition: background-color var(--transition-duration-slow) var(--transition-ease), border-color var(--transition-duration-slow) var(--transition-ease), opacity var(--transition-duration-slow) var(--transition-ease); }
 #master-title { margin-bottom: 0; cursor: default; position: relative; height: var(--logo-height); display: flex; align-items: center; justify-content: center; }
 #master-title svg { height: 100%; width: auto; display: block; }
 #master-title svg path, #master-title svg rect { fill: var(--secondary-text); /* WebKit Fix */ backface-visibility: hidden; -webkit-backface-visibility: hidden; }
 #header-controls-row { display: flex; flex-direction: row; align-items: stretch; gap: var(--header-controls-gap); width: 100%; align-self: stretch; }
 #header-controls-row > div { flex: 1; display: flex; justify-content: center; align-items: center; min-width: 0; height: var(--header-control-height); }
 #display-section { display: flex; flex-direction: column; align-items: stretch; background-color: var(--panel-bg-elevated); border-radius: 0; border-left: 1px solid var(--panel-border-color); border-right: 1px solid var(--panel-border-color); border-top: none; border-bottom: 1px solid var(--panel-border-color); padding: 0; gap: 0; transition: background-color var(--transition-duration-slow) var(--transition-ease), border-color var(--transition-duration-slow) var(--transition-ease); overflow: hidden; }
 #svg-container { display: block; width: 100%; height: auto; background-color: var(--svg-bg-color); position: relative; border: none; border-radius: 0; padding: var(--semantic-space-m); transition: background-color var(--transition-duration-slow) var(--transition-ease), opacity var(--transition-duration-slow) var(--transition-ease); }
 #console-panel { display: flex; flex-direction: column; align-items: stretch; border: none; border-radius: 0; border-top: 1px solid var(--panel-border-color); padding: var(--semantic-space-m); background-color: var(--svg-bg-color); transition: opacity var(--transition-duration-slow) var(--transition-ease), background-color var(--transition-duration-slow) var(--transition-ease), border-color var(--transition-duration-slow) var(--transition-ease); position: relative; z-index: 0; height: 5rem; overflow-y: auto; }
 #console-panel #message-box-container { padding: 0; border: none; background: none; box-shadow: none; display: flex; align-items: flex-start; align-self: stretch; min-height: 0; height: auto; max-height: none; overflow-y: visible; margin: 0; gap: 0; border-radius: 0; }
 #message-box-content { display: flex; flex-direction: column; width: 100%; text-align: left; font-family: var(--font-monospace); font-size: 0.8125rem; font-style: normal; font-weight: 500; line-height: 1rem; color: var(--console-text-color); background: none; border: none; border-radius: 0; padding: 0; min-height: 0; max-height: none; overflow-y: visible; white-space: pre-wrap; box-shadow: none; margin: 0; transition: color var(--transition-duration-slow) var(--transition-ease); }
 #message-box-content div { width: 100%; }
 #control-section { display: flex; justify-content: center; align-items: stretch; gap: var(--panel-gap); align-self: stretch; border-left: 1px solid var(--panel-border-color); border-right: 1px solid var(--panel-border-color); border-top: none; border-bottom: none; border-radius: 0; overflow: visible; background-color: var(--panel-bg-elevated); }
 .control-panel { border: none; border-radius: 0; padding: var(--semantic-space-m); display: flex; flex-direction: column; align-items: center; gap: var(--semantic-space-s); background-color: var(--panel-bg-elevated); transition: background-color var(--transition-duration-slow) var(--transition-ease); border-right: none; border-bottom: none; }
 #environment-panel, #hover-panel { flex-grow: 1; flex-basis: 0; min-width: 0; }
 #tap-panel { flex-grow: 0; flex-shrink: 0; flex-basis: auto; width: 8.9375rem; }
 #control-section > #environment-panel { border-bottom-left-radius: 0; }
 #control-section > #hover-panel { border-bottom-right-radius: 0; }
 .panel-label { color: var(--secondary-text); font-family: var(--font-headings); font-size: var(--label-medium-font-size); font-weight: var(--label-font-weight); line-height: 120%; letter-spacing: 0.015rem; margin-bottom: 0.5rem; text-align: center; width: 100%; margin-top: 0; transition: color var(--transition-duration-slow) var(--transition-ease), opacity var(--transition-duration-slow) var(--transition-ease); }
 #footer-container { padding: var(--semantic-space-m); display: flex; justify-content: center; align-items: center; background-color: var(--panel-bg-elevated); border-left: 1px solid var(--panel-border-color); border-right: 1px solid var(--panel-border-color); border-bottom: 1px solid var(--panel-border-color); border-radius: 0 0 var(--semantic-radius-xl) var(--semantic-radius-xl); transition: background-color var(--transition-duration-slow) var(--transition-ease), border-color var(--transition-duration-slow) var(--transition-ease); }
 #footer-credit { display: inline-flex; align-items: center; padding: var(--semantic-space-s) var(--semantic-space-m); font-family: var(--font-headings); font-size: var(--footer-font-size); line-height: 1.5; text-decoration: none; white-space: nowrap; color: var(--faint-control-text); background-color: transparent; border: none; border-radius: var(--semantic-radius-m); cursor: pointer; transition: color var(--transition-duration-medium) var(--transition-ease), background-color var(--transition-duration-medium) var(--transition-ease), padding-left var(--transition-duration-medium) var(--transition-ease); }
 #footer-credit:hover { color: var(--secondary-text); background-color: var(--interactive-bg-hover); padding-left: calc(var(--semantic-space-m) + 1.125em + var(--semantic-space-xs)); padding-right: var(--semantic-space-m); }
 #footer-credit .footer-icon { font-size: 1.125em; line-height: 1; opacity: 0; width: 0; margin-left: 0; overflow: hidden; vertical-align: middle; pointer-events: none; transition: opacity var(--transition-duration-medium) var(--transition-ease), width var(--transition-duration-medium) var(--transition-ease), margin-left var(--transition-duration-medium) var(--transition-ease); }
 #footer-credit:hover .footer-icon { opacity: 1; width: 1.125em; margin-left: var(--semantic-space-xs); pointer-events: auto; }

 /* ==========================================================================
    5. Specific Components
    ========================================================================== */

 /* --- Segmented Button / Toggles --- */
 .segmented-button { display: flex; padding: 0.375rem; justify-content: center; align-items: center; gap: 0.375rem; border-radius: 0.625rem; background: var(--interactive-bg); width: 100%; height: 100%; transition: background-color var(--transition-duration-medium) var(--transition-ease), opacity var(--transition-duration-slow) var(--transition-ease); }
 .segmented-button button { border-radius: var(--slider-thumb-radius); background-color: transparent; border: none; cursor: pointer; font-size: 0.875rem; color: var(--faint-control-text); font-weight: var(--button-font-weight); transition: background-color var(--transition-duration-medium) var(--transition-ease), color var(--transition-duration-medium) var(--transition-ease), box-shadow var(--transition-duration-medium) var(--transition-ease), font-weight var(--transition-duration-medium) var(--transition-ease); flex-grow: 1; flex-basis: 0; text-align: center; white-space: nowrap; height: var(--header-button-height); padding: calc((var(--header-button-height) - 0.875rem) / 2) 1.125rem; display: inline-flex; align-items: center; justify-content: center; line-height: 1; }
 .segmented-button button:not(.active):hover { background: var(--interactive-bg-hover); color: var(--accent-color); font-weight: calc(var(--button-font-weight) + 50); }
 .segmented-button button.active { background: var(--button-active-bg); box-shadow: var(--toggle-active-shadow); color: var(--toggle-active-text); font-weight: var(--button-font-weight); transition: background-color var(--transition-duration-slow) var(--transition-ease), color var(--transition-duration-medium) var(--transition-ease), box-shadow var(--transition-duration-medium) var(--transition-ease), font-weight var(--transition-duration-medium) var(--transition-ease); }
 #environment-panel .segmented-button button, #hover-panel .segmented-button button { height: 2rem; font-size: var(--button-font-size); padding: calc((2rem - var(--button-font-size)) / 2) 0.625rem; }
 #theme-toggle button { padding-left: 0.5rem; padding-right: 0.5rem; }
 #master-toggle button { padding-left: 0.5rem; padding-right: 0.5rem; }
 .theme-icon-circle { stroke-width: 0.125rem; transform-origin: center; transition: transform var(--transition-duration-fast) var(--transition-ease-out), fill var(--transition-duration-medium) var(--transition-ease), stroke var(--transition-duration-medium) var(--transition-ease); /* WebKit Fix */ backface-visibility: hidden; -webkit-backface-visibility: hidden; }
 .theme-icon-circle[data-theme-icon="light"] { fill: var(--theme-icon-light-fill); stroke: var(--theme-icon-light-stroke); }
 .theme-icon-circle[data-theme-icon="saturated"] { fill: var(--theme-icon-saturated-fill); stroke: var(--theme-icon-saturated-stroke); }
 .theme-icon-circle[data-theme-icon="dark"] { fill: var(--theme-icon-dark-fill); stroke: var(--theme-icon-dark-stroke); }
 #theme-toggle button:not(.active) .theme-icon-circle { transform: scale(0.75); }
 #theme-toggle button:not(.active):hover .theme-icon-circle { transform: scale(1); }
 #theme-toggle button.active .theme-icon-circle { transform: scale(1); }

/* --- Hue Slider --- */
#hue-slider-container { background: var(--interactive-bg); border-radius: 0.625rem; padding: 0.375rem 1rem; width: 100%; box-sizing: border-box; height: 100%; display: flex; align-items: center; transition: background-color var(--transition-duration-slow) var(--transition-ease), opacity var(--transition-duration-slow) var(--transition-ease); cursor: pointer; }
.hue-slider-track { width: 100%; height: var(--slider-track-height-hover); background: var(--slider-track-gradient); border-radius: var(--slider-track-radius); position: relative; cursor: inherit; transition: box-shadow var(--transition-duration-medium) var(--transition-ease); --slider-mask-height-factor: 1; }
.hue-slider-track::before, .hue-slider-track::after { content: ''; position: absolute; left: 0; right: 0; height: calc(((var(--slider-track-height-hover) - var(--slider-track-height-default)) / 2) * var(--slider-mask-height-factor)); background-color: var(--panel-bg-elevated); transition: background-color var(--transition-duration-slow) var(--transition-ease); z-index: 1; pointer-events: none; }
.hue-slider-track::before { top: 0; border-radius: var(--slider-track-radius) var(--slider-track-radius) 0 0; }
.hue-slider-track::after { bottom: 0; border-radius: 0 0 var(--slider-track-radius) var(--slider-track-radius); }
.hue-slider-hover-line { position: absolute; top: 0; left: 50%; width: var(--line-width-thick, 2px); height: 100%; background-color: var(--hover-indicator-color); opacity: 0; pointer-events: none; transition: opacity var(--transition-duration-fast) var(--transition-ease), background-color var(--transition-duration-slow) var(--transition-ease); z-index: 0; }
.hue-slider-thumb-container { position: absolute; top: calc((var(--slider-track-height-hover) - var(--slider-thumb-height)) / 2); left: var(--hue-slider-value-percent); transform: translateX(-50%); width: var(--slider-thumb-width); height: var(--slider-thumb-height); cursor: pointer; z-index: 2; display: flex; justify-content: center; align-items: center; }
.hue-slider-thumb { width: 100%; height: 100%; background-color: var(--button-active-bg); border-radius: var(--slider-thumb-radius); box-shadow: var(--slider-thumb-shadow); display: flex; justify-content: center; align-items: center; overflow: hidden; transition: background-color var(--transition-duration-slow) var(--transition-ease), box-shadow var(--transition-duration-medium) var(--transition-ease); /* WebKit Fix */ backface-visibility: hidden; -webkit-backface-visibility: hidden; }
.hue-slider-thumb .thumb-icon { font-family: 'Material Symbols Outlined'; font-weight: normal; font-style: normal; font-size: 1.2rem; line-height: 1; letter-spacing: normal; text-transform: none; display: inline-block; white-space: nowrap; word-wrap: normal; direction: ltr; -webkit-font-feature-settings: 'liga'; -webkit-font-smoothing: antialiased; color: var(--accent-color); transform: rotate(90deg); font-variation-settings: 'FILL' 0, 'wght' 400, 'GRAD' var(--slider-thumb-icon-grad, -25), 'opsz' 20; cursor: inherit; }

 /* --- Action Button --- */
 .action-button { display: flex; padding: 0.34375rem var(--semantic-space-s); justify-content: center; align-items: center; gap: 0.25rem; flex: 1 0 0; align-self: stretch; border-radius: var(--semantic-radius-s); border: 1px solid var(--panel-border-color); background: var(--interactive-bg); color: var(--accent-color); cursor: pointer; font-size: var(--button-font-size); font-weight: var(--button-font-weight); text-align: center; white-space: nowrap; box-shadow: var(--toggle-active-shadow); transition: transform var(--transition-duration-fast) var(--transition-ease), box-shadow var(--transition-duration-fast) var(--transition-ease), color var(--transition-duration-medium) var(--transition-ease), opacity var(--transition-duration-slow) var(--transition-ease), background-color var(--transition-duration-medium) var(--transition-ease), border-color var(--transition-duration-medium) var(--transition-ease), font-weight var(--transition-duration-medium) var(--transition-ease); --tap-icon-grad: -25; }
 .action-button .material-symbols-outlined { font-size: 1rem; color: inherit; position: relative; top: 0.0625rem; font-variation-settings: 'FILL' 0, 'wght' 400, 'GRAD' var(--tap-icon-grad, -25), 'opsz' 20; transition: color var(--transition-duration-medium) var(--transition-ease), font-variation-settings var(--transition-duration-medium) var(--transition-ease-out); /* WebKit Fix */ backface-visibility: hidden; -webkit-backface-visibility: hidden; }
 .action-button .button-text { display: inline; }
 .action-button:not(:disabled):hover { background: var(--interactive-bg-hover); color: var(--secondary-text); font-weight: calc(var(--button-font-weight) + 50); --tap-icon-grad: 300; }
 .action-button:not(:disabled):active { transform: scale(0.96); background-color: var(--interactive-bg-pressed); color: var(--secondary-text); box-shadow: none; font-weight: calc(var(--button-font-weight) + 50); --tap-icon-grad: 350; }
 .action-button:disabled { opacity: 0.5; cursor: not-allowed; box-shadow: none; transform: none; background-color: var(--interactive-bg); color: var(--toggle-inactive-text); font-weight: var(--button-font-weight); --tap-icon-grad: -25; }

 /* --- Dial Controls --- */
 .dial-area { display: flex; gap: 1.25rem; justify-content: center; width: 100%; margin-top: 0.25rem; transition: opacity var(--transition-duration-slow) var(--transition-ease); }
 .dial-container { display: flex; flex-direction: column; align-items: center; width: 4.0625rem; }
 .dial-label { font-size: var(--label-small-font-size); color: var(--faint-control-text); margin-bottom: 0.375rem; text-align: center; white-space: nowrap; transition: color var(--transition-duration-slow) var(--transition-ease); }
 .dial-svg-container { width: 3.75rem; height: 3.75rem; margin-bottom: 0.25rem; position: relative; }
 .dial-svg { width: 100%; height: 100%; cursor: pointer; overflow: visible; transition: opacity var(--transition-duration-slow) var(--transition-ease); }
 .dial-svg:active { cursor: pointer; }
 .dial-base { stroke: var(--dial-base-stroke); stroke-width: 0.03125; fill: var(--interactive-bg); filter: url(#dial-filter); transition: fill var(--transition-duration-medium) var(--transition-ease), stroke var(--transition-duration-slow) var(--transition-ease); }
 .dial-svg:hover .dial-base { fill: var(--interactive-bg-hover); }
 .dial-indicator { stroke: var(--accent-color); stroke-width: 3; stroke-linecap: round; transition: stroke var(--transition-duration-fast) var(--transition-ease); }
 .dial-division { stroke: var(--accent-color); stroke-linecap: round; transition: stroke var(--transition-duration-fast) var(--transition-ease); }
 .dial-value-display { font-family: var(--font-monospace); font-size: var(--value-font-size); font-weight: var(--value-font-weight); color: var(--secondary-text); text-align: center; min-width: 1.875rem; margin-top: 0.125rem; transition: color var(--transition-duration-slow) var(--transition-ease); }
 .dial-value-display[data-value-id="waveDirection"]::after { content: '°'; }

 /* --- SVG Element Styling --- */
 #interactive-svg circle:not(.cursor-circle):not(.pop-ring) { pointer-events: none; /* WebKit Fix */ backface-visibility: hidden; -webkit-backface-visibility: hidden; }
 #interactive-svg .cursor-circle { fill: none; stroke: var(--hover-indicator-color); stroke-width: 0.125; pointer-events: none; opacity: 0; transition: opacity var(--transition-duration-medium) var(--transition-ease-out), stroke var(--transition-duration-medium) var(--transition-ease); }
 #interactive-svg.mouse-over .cursor-circle { opacity: 1; }
 #interactive-svg .pop-ring { fill: none; pointer-events: none; }
 #interactive-svg #grid-lines-group line { stroke: var(--grid-line-color); stroke-width: 0.35; pointer-events: none; transition: stroke var(--transition-duration-medium) var(--transition-ease); }

 /* ==========================================================================
    6. Utility Styles (Sleep Mode)
    ========================================================================== */
 body.app-sleeping .dimmable-content { opacity: 0.4; pointer-events: none; transition: opacity var(--transition-duration-slow) var(--transition-ease); }
 body.app-sleeping #master-toggle { opacity: 1; pointer-events: auto; }
 body.app-sleeping #master-toggle button { opacity: 1; pointer-events: auto; cursor: pointer; }
 body.app-sleeping #hue-slider-container { opacity: 0.4; pointer-events: none; cursor: default !important; }
 body.app-sleeping .hue-slider-track, body.app-sleeping .hue-slider-thumb-container { cursor: default !important; }
 body.app-sleeping .dimmable-content :is(button, input[type=range], .dial-svg) { cursor: default !important; }
 body.app-sleeping #footer-container { pointer-events: auto; }
 body.app-sleeping #footer-credit { pointer-events: auto; cursor: default; }

 /* ==========================================================================
    7. Responsive Design (Mobile)
    ========================================================================== */
 @media (max-width: 500px) {
      :root { --header-control-height: 2.125rem; --logo-height: 1rem; --slider-track-height-default: 0.125rem; --slider-track-height-hover: 0.25rem; --slider-thumb-height: 1.375rem; --slider-thumb-width: 1.125rem; --header-button-height: 1.75rem; }
      body { padding: var(--semantic-space-m); }
      #main-content-area { margin-top: 0; max-width: 100%; }
      #master-panel-wrapper { padding: var(--semantic-space-xs); border-radius: calc(var(--semantic-radius-xl) + var(--semantic-space-xs)); border-width: 1px; }
      #control-console-frame { gap: var(--panel-gap); border-radius: var(--semantic-radius-xl); }
      #header-section { padding: var(--semantic-space-s); padding-top: var(--semantic-space-xl); border-radius: var(--semantic-radius-xl) var(--semantic-radius-xl) 0 0; border-bottom: 1px solid var(--panel-border-color); }
      #header-controls-row { gap: var(--header-controls-gap); }
      #hue-slider-container { padding: 0.375rem 0.5rem; }
      .hue-slider-thumb-container { top: calc((var(--slider-track-height-hover) - var(--slider-thumb-height)) / 2); }
      .hue-slider-thumb .thumb-icon { font-size: 1rem; }
      .segmented-button button { height: var(--header-button-height); font-size: 0.8125rem; padding-top: calc((var(--header-button-height) - 0.8125rem) / 2); padding-bottom: calc((var(--header-button-height) - 0.8125rem) / 2); }
      .segmented-button button:not(.active):hover, .action-button:not(:disabled):hover { font-weight: var(--button-font-weight); background: var(--interactive-bg); color: var(--faint-control-text); --tap-icon-grad: -25;} /* Reduce hover */
      .action-button:not(:disabled):active { font-weight: var(--button-font-weight); background-color: var(--interactive-bg-pressed); color: var(--secondary-text); --tap-icon-grad: 350; transform: scale(0.96); } /* Keep active */
      #theme-toggle button:not(.active):hover .theme-icon-circle { transform: scale(0.75); } /* Reduce hover */
      #theme-toggle button, #master-toggle button { padding-left: 0.4rem; padding-right: 0.4rem; }
      #environment-panel .segmented-button button, #hover-panel .segmented-button button { height: 2rem; font-size: var(--button-font-size); padding: calc((2rem - var(--button-font-size)) / 2) 0.625rem; }
      #display-section { border-left: 1px solid var(--panel-border-color); border-right: 1px solid var(--panel-border-color); border-top: none; border-bottom: 1px solid var(--panel-border-color); border-radius: 0; padding: 0; }
      #svg-container { padding: var(--semantic-space-s); border-radius: 0; border: none; }
      #console-panel { padding: var(--semantic-space-s); border-radius: 0; border: none; border-top: 1px solid var(--panel-border-color); }
      #control-section { flex-direction: column; gap: var(--panel-gap); border: none; border-radius: 0; }
      .control-panel { width: 100%; flex-basis: auto; flex-grow: 0; border-radius: 0; border-right: none; border-left: 1px solid var(--panel-border-color); border-right: 1px solid var(--panel-border-color); border-top: none; border-bottom: none; }
      #tap-panel { order: 2; width: 100%; flex-direction: row; gap: var(--semantic-space-s); padding: 0 var(--semantic-space-s); }
      #environment-panel { order: 1; padding: var(--semantic-space-s); border-bottom: none; }
      #hover-panel { order: 3; display: none; }
      #footer-container { padding: var(--semantic-space-s) var(--semantic-space-xl); }
      #footer-credit { padding: var(--semantic-space-s) var(--semantic-space-s); }
      #footer-credit:hover { color: var(--faint-control-text); background-color: transparent; padding-left: var(--semantic-space-s); padding-right: var(--semantic-space-s); } /* Reduce hover */
      #footer-credit:hover .footer-icon { opacity: 0; width: 0; margin-left: 0; } /* Hide icon on hover */
      #tap-panel .action-button { flex-grow: 1; flex-basis: 0; padding-left: var(--semantic-space-xs); padding-right: var(--semantic-space-xs); min-width: 0; }
      #tap-panel .action-button .button-text { display: none; }
      #tap-panel .action-button .material-symbols-outlined { font-size: 1.25rem; margin-right: 0; }
      #environment-panel .dial-area { display: none; }
      #environment-panel .panel-label, #tap-panel .panel-label { display: none; }
 }
    </style>
</head>
<body>
    <!-- Hidden SVG for filter definitions -->
    <svg width="0" height="0" style="position:absolute;overflow:hidden;">
        <defs>
            <filter id="dial-filter" x="-30%" y="-30%" width="160%" height="160%" filterUnits="objectBoundingBox" color-interpolation-filters="sRGB"> <feFlood flood-opacity="0" result="BackgroundImageFix"/> <feColorMatrix in="SourceAlpha" type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0" result="hardAlpha1"/> <feOffset dy="2"/> <feGaussianBlur stdDeviation="2"/> <feComposite in2="hardAlpha1" operator="out"/> <feColorMatrix type="matrix" values="0 0 0 0 0  0 0 0 0 0  0 0 0 0 0  0 0 0 0.1 0"/> <feBlend mode="normal" in2="BackgroundImageFix" result="effect1_dropShadow"/> <feColorMatrix in="SourceAlpha" type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0" result="hardAlpha2"/> <feOffset dy="4"/> <feGaussianBlur stdDeviation="4"/> <feComposite in2="hardAlpha2" operator="out"/> <feColorMatrix type="matrix" values="0 0 0 0 0  0 0 0 0 0  0 0 0 0 0  0 0 0 0.1 0"/> <feBlend mode="normal" in2="effect1_dropShadow" result="effect2_dropShadow"/> <feColorMatrix in="SourceAlpha" type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0" result="hardAlpha3"/> <feOffset dy="8"/> <feGaussianBlur stdDeviation="8"/> <feComposite in2="hardAlpha3" operator="out"/> <feColorMatrix type="matrix" values="0 0 0 0 0  0 0 0 0 0  0 0 0 0 0  0 0 0 0.1 0"/> <feBlend mode="normal" in2="effect2_dropShadow" result="effect3_dropShadow"/> <feMerge> <feMergeNode in="effect3_dropShadow"/> <feMergeNode in="SourceGraphic"/> </feMerge> </filter>
            <filter id='noiseFilter'> <feTurbulence type='fractalNoise' baseFrequency='0.8' numOctaves='4' stitchTiles='stitch'/> <feColorMatrix type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.16 0" /> </filter>
        </defs>
    </svg>

    <div id="main-content-area">
        <div id="master-panel-wrapper">
            <div id="control-console-frame">
                <!-- Header Section -->
                <div id="header-section">
                    <div id="master-title">
                        <svg id="dfx-logo-svg" viewBox="0 0 252 40" fill="none" xmlns="http://www.w3.org/2000/svg">
                            <!-- SVG Paths -->
                            <path d="M6.68191 15.5701L14.7554 11.0094V32.0407H20.2454C26.9391 32.0407 33.6328 30.2687 33.6328 20.0436C33.6328 9.81844 27.2033 8.04648 20.2454 8.04648H0.0175781V0H20.2454C31.8419 0 41.5008 4.79303 41.5008 20.0436C41.5008 35.2941 31.0199 40 20.2454 40H6.68191V15.5701Z"/>
                            <path d="M52.2291 40V0H87.1949L98.7914 13.8272L110.417 0H117.317H121.016L104.105 20L121.016 40H117.317H110.417L98.7914 26.1728L87.0775 40H78.4619H76.5672L93.4482 20L83.3783 8.04648H60.2733V16.0639H76.5672V24.1104H60.2733V40H52.2291Z"/>
                            <rect x="41" y="32" width="8" height="8"/>
                            <path d="M124.129 12.3542H117.629L128.501 0H135.001V40H130.001V5L124.129 12.3542Z"/>
                            <path fill-rule="evenodd" clip-rule="evenodd" d="M144 0C141.791 0 140 1.79086 140 4V36C140 38.2091 141.791 40 144 40H170C172.209 40 174 38.2091 174 36V4C174 1.79086 172.209 0 170 0H144ZM169 5H145V35H169V5Z"/>
                            <path fill-rule="evenodd" clip-rule="evenodd" d="M222 0C219.791 0 218 1.79086 218 4V36C218 38.2091 219.791 40 222 40H248C250.209 40 252 38.2091 252 36V4C252 1.79086 250.209 0 248 0H222ZM247 5H223V35H247V5Z"/>
                            <path fill-rule="evenodd" clip-rule="evenodd" d="M183 0C180.791 0 179 1.79086 179 4V36C179 38.2091 180.791 40 183 40H209C211.209 40 213 38.2091 213 36V4C213 1.79086 211.209 0 209 0H183ZM208 5H184V35H208V5Z"/>
                        </svg>
                    </div>
                    <div id="header-controls-row">
                         <div><div id="master-toggle" class="segmented-button"> <button data-master-mode="sleep">OFF</button> <button data-master-mode="activated" class="active">ON</button> </div></div>
                         <div>
                             <div id="hue-slider-container" class="dimmable-content">
                                 <div class="hue-slider-track" id="hue-track">
                                     <div class="hue-slider-hover-line" id="hue-hover-line"></div>
                                     <div class="hue-slider-thumb-container" id="hue-thumb-container">
                                         <div class="hue-slider-thumb" id="hue-thumb">
                                             <span class="material-symbols-outlined thumb-icon" id="thumb-icon">drag_handle</span>
                                         </div>
                                     </div>
                                 </div>
                             </div>
                         </div>
                         <div><div id="theme-toggle" class="segmented-button dimmable-content"> <button data-theme="light" class="active"> <svg viewBox="0 0 20 20" width="1rem" height="1rem" aria-label="Light Theme" focusable="false"> <circle cx="10" cy="10" r="8" class="theme-icon-circle" data-theme-icon="light"/> </svg> </button> <button data-theme="saturated"> <svg viewBox="0 0 20 20" width="1rem" height="1rem" aria-label="Saturated Theme" focusable="false"> <circle cx="10" cy="10" r="8" class="theme-icon-circle" data-theme-icon="saturated"/> </svg> </button> <button data-theme="dark"> <svg viewBox="0 0 20 20" width="1rem" height="1rem" aria-label="Dark Theme" focusable="false"> <circle cx="10" cy="10" r="8" class="theme-icon-circle" data-theme-icon="dark"/> </svg> </button> </div></div>
                    </div>
                </div>

                <!-- Display Section -->
                <div id="display-section">
                    <div id="svg-container" class="dimmable-content"> <svg id="interactive-svg"></svg> </div>
                    <div id="console-panel" class="dimmable-content"> <div id="message-box-container"> <pre id="message-box-content"></pre> </div> </div>
                </div>

                 <!-- Control Section -->
                 <div id="control-section">
                    <div id="environment-panel" class="control-panel">
                         <h4 class="panel-label dimmable-content">Environment</h4>
                         <div class="segmented-button dimmable-content" id="effect-type-toggle"> <button data-effect-type="sparkle" class="active">Sparkle</button> <button data-effect-type="wave">Wave</button> </div>
                         <div class="dial-area dimmable-content" id="effect-dials">
                             <div class="dial-container" data-effect-type="wave"> <span class="dial-label">Direction</span> <div class="dial-svg-container"> <svg class="dial-svg" data-dial-id="waveDirection" viewBox="-15 -15 70 70"> <circle class="dial-base" cx="20" cy="20" r="18" /> <g class="dial-decorations"></g> <g class="dial-indicator-group" transform-origin="20 20"> <line class="dial-indicator" x1="20" y1="20" x2="36" y2="20"/> </g> </svg> </div> <span class="dial-value-display" data-value-id="waveDirection"></span> </div>
                             <div class="dial-container" data-effect-type="wave"> <span class="dial-label">Power</span> <div class="dial-svg-container"> <svg class="dial-svg" data-dial-id="waveSize" viewBox="-15 -15 70 70"> <circle class="dial-base" cx="20" cy="20" r="18" /> <g class="dial-decorations"></g> <g class="dial-indicator-group" transform-origin="20 20"> <line class="dial-indicator" x1="20" y1="20" x2="36" y2="20"/> </g> </svg> </div> <span class="dial-value-display" data-value-id="waveSize"></span> </div>
                             <div class="dial-container" data-effect-type="sparkle"> <span class="dial-label">Frequency</span> <div class="dial-svg-container"> <svg class="dial-svg" data-dial-id="sparkleFreq" viewBox="-15 -15 70 70"> <circle class="dial-base" cx="20" cy="20" r="18" /> <g class="dial-decorations"></g> <g class="dial-indicator-group" transform-origin="20 20"> <line class="dial-indicator" x1="20" y1="20" x2="36" y2="20"/> </g> </svg> </div> <span class="dial-value-display" data-value-id="sparkleFreq"></span> </div>
                             <div class="dial-container" data-effect-type="sparkle"> <span class="dial-label">Power</span> <div class="dial-svg-container"> <svg class="dial-svg" data-dial-id="sparkleSize" viewBox="-15 -15 70 70"> <circle class="dial-base" cx="20" cy="20" r="18" /> <g class="dial-decorations"></g> <g class="dial-indicator-group" transform-origin="20 20"> <line class="dial-indicator" x1="20" y1="20" x2="36" y2="20"/> </g> </svg> </div> <span class="dial-value-display" data-value-id="sparkleSize"></span> </div>
                         </div>
                     </div>
                     <div id="tap-panel" class="control-panel">
                         <h4 class="panel-label dimmable-content" id="tap-label">Tap</h4>
                         <button id="tap-button" class="action-button dimmable-content"> <span class="material-symbols-outlined" id="bomb-icon">bomb</span> <span class="button-text">Bomb</span> </button>
                          <button id="jiggle-button" class="action-button dimmable-content"> <span class="material-symbols-outlined" id="shake-icon">earthquake</span> <span class="button-text">Shake</span> </button>
                          <button id="wave-tap-button" class="action-button dimmable-content"> <span class="material-symbols-outlined">adjust</span> <span class="button-text">Pulse</span> </button>
                     </div>
                     <div id="hover-panel" class="control-panel">
                          <h4 class="panel-label dimmable-content">Mouse Hover</h4>
                          <div class="segmented-button dimmable-content" id="hover-type-toggle"> <button data-hover-type="repel" class="active">Repel</button> <button data-hover-type="attract">Attract</button> </div>
                          <div class="dial-area dimmable-content" id="hover-dials">
                              <div class="dial-container"> <span class="dial-label">Falloff</span> <div class="dial-svg-container"> <svg class="dial-svg" data-dial-id="hoverFalloff" viewBox="-15 -15 70 70"> <circle class="dial-base" cx="20" cy="20" r="18" /> <g class="dial-decorations"></g> <g class="dial-indicator-group" transform-origin="20 20"> <line class="dial-indicator" x1="20" y1="20" x2="36" y2="20"/> </g> </svg> </div> <span class="dial-value-display" data-value-id="hoverFalloff"></span> </div>
                              <div class="dial-container"> <span class="dial-label" id="hover-power-label">Power</span> <div class="dial-svg-container"> <svg class="dial-svg" data-dial-id="hoverPower" viewBox="-15 -15 70 70"> <circle class="dial-base" cx="20" cy="20" r="18" /> <g class="dial-decorations"></g> <g class="dial-indicator-group" transform-origin="20 20"> <line class="dial-indicator" x1="20" y1="20" x2="36" y2="20"/> </g> </svg> </div> <span class="dial-value-display" data-value-id="hoverPower"></span> </div>
                          </div>
                     </div>
                </div>

                <!-- Footer Credit Section -->
                <div id="footer-container">
                    <a id="footer-credit" href="https://davethompson.design" target="_blank" rel="noopener noreferrer">
                        <span class="footer-text">Made with pixels. © Dave Thompson Design</span>
                        <span class="material-symbols-outlined footer-icon">open_in_new</span>
                    </a>
                </div>

            </div> <!-- END control-console-frame -->
        </div> <!-- END master-panel-wrapper -->
    </div> <!-- END main-content-area -->

    <script>
    // Immediately Invoked Function Expression (IIFE) to encapsulate the code
    (() => {
        'use strict';

        // ==========================================================================
        // 1. Configuration & Message Strings (FASTER SPECIAL - Durations halved)
        // ==========================================================================
        const config = { TARGET_SVG_WIDTH: 500, VIEWBOX_PADDING_UNITS: 50, DOT_DIAMETER_INITIAL: 4, INITIAL_HOVER_MODE: 'repel', INITIAL_HOVER_FALLOFF: 60, INITIAL_ATTRACT_POWER: 4, INITIAL_REPEL_POWER: 4, ANIMATION_DURATION_HOVER_POS: 0.2, ANIMATION_DURATION_LEAVE: 0.3, INITIAL_ACTIVE_EFFECT: 'sparkle', INITIAL_WAVE_DIRECTION_ANGLE: 60, INITIAL_WAVE_SIZE_INCREASE: 6.0, INITIAL_WAVE_SPEED_FACTOR: 4.0, WAVE_EXPAND_DURATION: 0.2, WAVE_SHRINK_DELAY: 0.05, WAVE_SHRINK_DURATION: 0.3, BASE_WAVE_CROSS_DURATION: 0.75, WAVE_REPEAT_DELAY: 2, INITIAL_SPARKLE_SIZE_INCREASE: 6.0, INITIAL_SPARKLE_FREQUENCY: 0.75, SPARKLE_BASE_DURATION: 0.4, SPARKLE_BASE_DELAY: 0.1, SPARKLE_MIN_DURATION_FACTOR: 0.8, SPARKLE_MAX_DURATION_FACTOR: 1.2, SPARKLE_MIN_DELAY_FACTOR: 0, SPARKLE_MAX_DELAY_FACTOR: 0.5, POP_DURATION: 0.6, POP_FINAL_RADIUS: 45, POP_STROKE_WIDTH: 1.5, POP_INITIAL_OPACITY: 0.9, RING_HUE_INCREMENT: 30, SHAKE_AMOUNT: 16, SHAKE_DURATION: 0.3, SHAKE_DELAY_MAX: 0.1, PULSE_DURATION: 0.6, PULSE_MAX_RADIUS_INCREASE: 4, PULSE_MAX_Y_DISPLACEMENT: 12, PULSE_TOTAL_STAGGER: 0.4, INTRO_ANIM_DURATION: 0.8, INTRO_ANIM_STAGGER: 0.005, INTRO_ANIM_RANDOM_DELAY: 0.3, DIAL_ANGLE_MIN: 0, DIAL_ANGLE_MAX: 360, DIAL_WAVE_SIZE_MIN: 1, DIAL_WAVE_SIZE_MAX: 11, DIAL_SPARKLE_SIZE_MIN: 1, DIAL_SPARKLE_SIZE_MAX: 11, DIAL_SPARKLE_FREQ_MIN: 0.5, DIAL_SPARKLE_FREQ_MAX: 2.5, DIAL_FALLOFF_MIN: 20, DIAL_FALLOFF_MAX: 420, DIAL_POWER_MIN: 1, DIAL_POWER_MAX: 11, WAVE_SIZE_INTERNAL_MIN: 1, WAVE_SIZE_INTERNAL_MAX: 5, SPARKLE_SIZE_INTERNAL_MIN: 0.5, SPARKLE_SIZE_INTERNAL_MAX: 4.5, HOVER_POWER_INTERNAL_MIN: 10, HOVER_POWER_INTERNAL_MAX: 200, DIAL_ANGLE_PHYSICAL_MIN: 120, DIAL_ANGLE_PHYSICAL_MAX: 60, DIAL_TOTAL_ANGLE_RANGE: 300, EPSILON: 1e-6, GRID_SPACING: 20, SATURATED_HOVER_LIGHTNESS_INCREASE: 0.2, SATURATED_HOVER_CHROMA_INCREASE: 0.1, HUE_UPDATE_DEBOUNCE: 150, HUE_CHANGE_THRESHOLD: 5, HUE_RANGES: { red: { min: 0, max: 40, key: 'hueRed' }, orange: { min: 40, max: 70, key: 'hueOrange' }, yellow: { min: 70, max: 110, key: 'hueYellow' }, green: { min: 110, max: 160, key: 'hueGreen' }, cyan: { min: 160, max: 210, key: 'hueCyan' }, blue: { min: 210, max: 290, key: 'hueBlue' }, purple: { min: 290, max: 360, key: 'huePurple' } }, MASTER_PANEL_GRADIENT_ENABLED: true, MASTER_PANEL_GRADIENT_SPEED: 4, MASTER_PANEL_GRADIENT_HUE_L: 0.85, MASTER_PANEL_GRADIENT_HUE_C: 0.15, MASTER_PANEL_GRADIENT_NEUTRAL: 'oklch(0.95 0.01 0)', LOGO_DIM_OPACITY: 0.4, LOGO_FLICKER_DURATION: 0.03, LOGO_FLICKER_COUNT: 7, LOGO_OSCILLATE_DURATION: 2.5, LOGO_OSCILLATE_OPACITY_MIN: 0.95, };
        const appMessages = { startup: ["DFX 1000 Online", "System activated", "Ready for interaction", "Console initialized"], sleep: ["Entering sleep mode", "System standby", "Powering down", "Goodnight, dots"], activate: ["System activated", "Waking up...", "Effects online", "Let's get interactive!"], hueRed: ["Feeling fiery red", "Red spectrum engaged", "Warming things up", "Hue: Crimson"], hueOrange: ["Orange hues selected", "Sunset vibes", "Tangerine dream", "Hue: Amber"], hueYellow: ["Sunshine yellow active", "Golden hour", "Lemon zest", "Hue: Yellow"], hueGreen: ["Going green", "Emerald tones", "Forest canopy", "Hue: Verdant"], hueCyan: ["Cool cyan selected", "Aqua marine flow", "Icy blues", "Hue: Cyan"], hueBlue: ["Deep blue spectrum", "Oceanic vibes", "Midnight sky", "Hue: Azure"], huePurple: ["Purple reigns", "Violet spectrum", "Magenta magic", "Hue: Amethyst"], bomb: ["Kapow!", "Bam!", "Wham!", "Bombs away!", "Checkmate", "Direct hit", "Photon torpedos launched", "Target acquired", "Destruction was a last resort"], shake: ["Shake it!", "Shakin', not stirred...", "Rumble!", "Quake activated!", "Jiggle physics!"], pulse: ["Resonance engaged", "Oscillations initiated", "Dotwave propagating", "Signal sent", "Pulse wave!"], effectWave: ["Light sweep online", "Wavy gravy", "Pixel surf", "Photon tsunami", "Wave mode activated"], effectSparkle: ["Make it sparkle", "Pixel confetti", "The world needs more sparkle", "Bit bling", "LED it snow", "Sparkle mode engaged"], hoverAttract: ["Gravity field anchored", "Inward bias activated", "Field compression: ON", "Attraction mode"], hoverRepel: ["Negative charge applied", "Gravity field reversed", "Evasive pattern applied", "Not everything is meant to be together", "Repulsion mode"], themeLight: ["Light theme set", "Classic illumination", "Day mode"], themeSaturated: ["Saturated theme active", "Vibrant colors engaged", "Chroma boost!"], themeDark: ["Dark theme set", "Entering the void", "Night mode"], dialMax: ["Setting to 11? Holy Smokes", "Maximum Power!", "Limit Reached", "Full throttle", "11 set. Good gracious", "Cranked to the max!"], dialMin: ["Nice and easy", "Minimum reached", "Dialed down", "Lowest setting", "Taking it slow"], dialIncreaseGeneric: ["Parameter increased", "Boosting level", "Turning it up", "More power!"], dialDecreaseGeneric: ["Parameter decreased", "Lowering level", "How low can we go", "Dialing it back", "Less intensity"], dialIncreaseFreq: ["Frequency up", "Faster pulses", "Increasing rate", "Higher tempo"], dialDecreaseFreq: ["Frequency down", "Slower pulses", "Decreasing rate", "Lower tempo"], directionEast: ["Heading East", "Eastward bound"], directionSouth: ["Flying South", "Southward trajectory"], directionWest: ["Go West", "Westward ho!"], directionNorth: ["Traveling North", "Northward path"], directionGeneral: ["This is the way", "Direction changed", "New heading set", "Orientation updated"], };

        // ==========================================================================
        // 2. Theme Definitions
        // ==========================================================================
        const themes = { light: { name: 'Light', cssClass: '', messageKey: 'themeLight', bodyBg: { l: 0.97, c: 0.003, hueSensitive: true }, bodyTextColor: { l: 0.15, c: 0.00, h: 0 }, panelBgBase: { l: 0.96, c: 0.01, h: 0, hueSensitive: true }, panelBgElevated: { l: 1.00, c: 0.00, h: 0 }, panelBgSunken: { l: 0.93, c: 0.01, h: 0, hueSensitive: true }, panelBorder: { l: 0.89, c: 0.02, hueSensitive: true }, panelText: { l: 0.10, c: 0.02, h: 270 }, panelLabel: { l: 0.10, c: 0.02, h: 270 }, toggleActiveText: { l: 0.07, c: 0.1, h: 0 }, toggleInactiveText: { l: 0.37, c: 0.21, h: 0 }, dialBaseStroke: { l: 0.80, c: 0.00, h: 0 }, gridLine: { l: 0.5, c: 0.13, a: 0.30, hueSensitive: true }, dotSleep: { l: 0.78, c: 0.03, h: 270, hueSensitive: false }, accent: { l: 0.51, c: 0.08, hueSensitive: true }, interactiveBg: { l: 0.30, c: 0.036, a: 0.06, hueSensitive: true }, interactiveBgHover: { l: 0.47, c: 0.191, a: 0.10, hueSensitive: true }, interactiveBgPressed:{ l: 0.42, c: 0.191, a: 0.10, hueSensitive: true }, svgBg: { l: 0.30, c: 0.036, a: 0.06, hueSensitive: true }, dotHover: { l: 0.60, c: 0.18, hueSensitive: true }, bombRing: { l: 0.80, c: 0.23, hueSensitive: true }, dotRestingColor: '#333333', themeIconLightFill: { l: 1.00, c: 0.00, h: 0 }, themeIconLightStroke: { l: 0.40, c: 0.01, h: 255 }, themeIconSaturatedFill:{ l: 0.70, c: 0.25, hueSensitive: true }, themeIconSaturatedStroke:{ l: 0.60, c: 0.25, hueSensitive: true }, themeIconDarkFill: { l: 0.27, c: 0.00, h: 0 }, themeIconDarkStroke: { l: 0.20, c: 0.02, h: 255 }, faintControlText: { l: 0.5, c: 0.03, hueSensitive: true }, secondaryText: { l: 0.34, c: 0.1, hueSensitive: true }, masterPanelBorder: 'rgba(255, 255, 255, 1)', masterPanelBg: 'rgba(255, 255, 255, 0.20)', }, saturated: { name: 'Saturated', cssClass: 'saturated-theme-active', messageKey: 'themeSaturated', bodyBg: { l: 0.97, c: 0.016, hueSensitive: true }, bodyTextColor: { l: 0.00, c: 0.00, h: 0 }, panelBgBase: { l: 0.95, c: 0.03, hueSensitive: true }, panelBgElevated: { l: 1.00, c: 0.00, h: 0 }, panelBgSunken: { l: 0.92, c: 0.03, hueSensitive: true }, panelBorder: { l: 0.90, c: 0.05, hueSensitive: true }, panelText: { l: 0.00, c: 0.00, h: 0 }, panelLabel: { l: 0.00, c: 0.00, h: 0 }, toggleActiveText: { l: 0.00, c: 0.00, h: 0 }, toggleInactiveText: { l: 0.20, c: 0.00, h: 0 }, gridLine: { l: 0.50, c: 0.03, a: 0.40, hueSensitive: true }, dotSleep: { l: 0.40, c: 0.10, hueSensitive: true }, accent: { l: 0.40, c: 0.15, hueSensitive: true }, interactiveBg: { l: 0.50, c: 0.15, a: 0.10, hueSensitive: true }, interactiveBgHover: { l: 0.47, c: 0.310, a: 0.10, hueSensitive: true }, interactiveBgPressed:{ l: 0.42, c: 0.310, a: 0.10, hueSensitive: true }, svgBg: { l: 0.50, c: 0.15, a: 0.10, hueSensitive: true }, dotHover: { l: 0.75, c: 0.26, hueSensitive: true }, bombRing: { l: 0.90, c: 0.23, hueSensitive: true }, dialBaseStroke: 'var(--panel-border-color)', themeIconLightFill: { l: 1.00, c: 0.00, h: 0 }, themeIconLightStroke: { l: 0.80, c: 0.05, hueSensitive: true }, themeIconSaturatedFill:{ l: 0.70, c: 0.25, hueSensitive: true }, themeIconSaturatedStroke:{ l: 0.20, c: 0.20, hueSensitive: true }, themeIconDarkFill: { l: 0.30, c: 0.05, hueSensitive: true }, themeIconDarkStroke: { l: 0.50, c: 0.05, hueSensitive: true }, faintControlText: { l: 0.5, c: 0.09, hueSensitive: true }, secondaryText: { l: 0.34, c: 0.15, hueSensitive: true }, masterPanelBorder: 'rgba(255, 255, 255, 1)', masterPanelBg: 'rgba(255, 255, 255, 0.20)', }, dark: { name: 'Dark', cssClass: 'dark-theme', messageKey: 'themeDark', bodyBg: { l: 0.25, c: 0.003, hueSensitive: true }, bodyTextColor: { l: 0.88, c: 0.00, h: 0 }, panelBgBase: { l: 0.22, c: 0.01, h: 0, hueSensitive: true }, panelBgElevated: { l: 0.15, c: 0.001, h: 0 }, panelBgSunken: { l: 0.15, c: 0.00, h: 0, hueSensitive: true }, panelBorder: { l: 0.55, c: 0.02, hueSensitive: true }, panelText: { l: 0.88, c: 0.00, h: 0 }, panelLabel: { l: 0.88, c: 0.00, h: 0 }, toggleActiveText: { l: 1.00, c: 0.00, h: 0 }, toggleInactiveText: { l: 0.67, c: 0.00, h: 0 }, dialBaseStroke: { l: 0.33, c: 0.00, h: 0 }, gridLine: { l: 0.45, c: 0.04, a: 0.75, hueSensitive: true }, dotSleep: { l: 0.33, c: 0.01, h: 270, hueSensitive: false }, accent: { l: 0.82, c: 0.08, hueSensitive: true }, interactiveBg: { l: 0.70, c: 0.036, a: 0.06, hueSensitive: true }, interactiveBgHover: { l: 0.53, c: 0.191, a: 0.10, hueSensitive: true }, interactiveBgPressed:{ l: 0.45, c: 0.20, a: 0.10, hueSensitive: true }, svgBg: { l: 0.70, c: 0.036, a: 0.06, hueSensitive: true }, dotHover: { l: 0.85, c: 0.20, hueSensitive: true }, bombRing: { l: 0.55, c: 0.23, hueSensitive: true }, dotRestingColor: '#E0E0E0', themeIconLightFill: { l: 0.80, c: 0.00, h: 0 }, themeIconLightStroke: { l: 0.20, c: 0.01, h: 255 }, themeIconSaturatedFill:{ l: 0.60, c: 0.20, hueSensitive: true }, themeIconSaturatedStroke:{ l: 0.2, c: 0.05, hueSensitive: true }, themeIconDarkFill: { l: 0.18, c: 0.01, h: 0 }, themeIconDarkStroke: { l: 0.85, c: 0.02, h: 255 }, faintControlText: { l: 0.75, c: 0.03, hueSensitive: true }, secondaryText: { l: 0.9, c: 0.1, hueSensitive: true }, masterPanelBorder: 'rgba(255, 255, 255, 0.20)', masterPanelBg: 'rgba(255, 255, 255, 0.10)', } };

        // ==========================================================================
        // 3. Constants & Global State
        // ==========================================================================
        const constants = { SVG_NS: 'http://www.w3.org/2000/svg', DEG_TO_RAD: Math.PI / 180 };
        const state = { masterMode: 'activated', activeHoverMode: config.INITIAL_HOVER_MODE, activeEffect: config.INITIAL_ACTIVE_EFFECT, currentTheme: 'light', brandHue: 255, isDraggingDial: false, isDraggingSvg: false, dragDialInfo: { element: null, center: { x: 0, y: 0 }, initialValue: null, hitMin: false, hitMax: false }, isMouseOverSvg: false, waveTimeline: null, sparkleTweens: [], dots: [], messageLog: [], messageIndices: {}, waveDirectionAngle: config.INITIAL_WAVE_DIRECTION_ANGLE, waveSizeIncrease: mapRange(config.INITIAL_WAVE_SIZE_INCREASE, config.DIAL_WAVE_SIZE_MIN, config.DIAL_WAVE_SIZE_MAX, config.WAVE_SIZE_INTERNAL_MIN, config.WAVE_SIZE_INTERNAL_MAX), sparkleFrequency: config.INITIAL_SPARKLE_FREQUENCY, sparkleSizeIncrease: mapRange(config.INITIAL_SPARKLE_SIZE_INCREASE, config.DIAL_SPARKLE_SIZE_MIN, config.DIAL_SPARKLE_SIZE_MAX, config.SPARKLE_SIZE_INTERNAL_MIN, config.SPARKLE_SIZE_INTERNAL_MAX), hoverFalloff: config.INITIAL_HOVER_FALLOFF, hoverPower: mapRange(config.INITIAL_HOVER_MODE === 'repel' ? config.INITIAL_REPEL_POWER : config.INITIAL_ATTRACT_POWER, config.DIAL_POWER_MIN, config.DIAL_POWER_MAX, config.HOVER_POWER_INTERNAL_MIN, config.HOVER_POWER_INTERNAL_MAX), currentRingHue: themes.light.bombRing?.h ?? 255, resizeTimer: null, hueUpdateTimer: null, isDraggingHueSlider: false, hueSliderTrackRect: null, initialHueOnDragStart: 255, logoAnimationTimeline: null, };

        // ==========================================================================
        // 4. DOM References & Geometry
        // ==========================================================================
        const domRefs = {};
        const geometry = { gridCenter: { x: 0, y: 0 }, svgRect: null, viewBoxParams: null, ctmInverse: null, scaleFactor: 1 };

        // ==========================================================================
        // 5. Helper Functions
        // ==========================================================================
        function degreesToRadians(d) { return d * constants.DEG_TO_RAD; }
        function radiansToDegrees(r) { return r * (180 / Math.PI); }
        function getWaveDistanceMetric(x, y, angleRad) { const wx = Math.cos(angleRad), wy = Math.sin(angleRad); return x * wx + y * wy; }
        function distance(x1, y1, x2, y2) { const dx = x1 - x2, dy = y1 - y2; return Math.sqrt(dx * dx + dy * dy); }
        function clamp(v, min, max) { return Math.max(min, Math.min(v, max)); }
        function mapRange(v, iMin, iMax, oMin, oMax) { if (Math.abs(iMax - iMin) < config.EPSILON) return oMin; return oMin + (oMax - oMin) * (v - iMin) / (iMax - iMin); }
        function createSvgElement(type, attributes = {}) { const el = document.createElementNS(constants.SVG_NS, type); for (const [key, value] of Object.entries(attributes)) { el.setAttribute(key, value); } return el; }
        const formatFloat = v => (typeof v === 'number' ? v.toFixed(1) : 'N/A');
        const formatInt = v => (typeof v === 'number' ? Math.round(v) : 'N/A');
        function getCssVarAsNumber(varName) { try { return parseFloat(getComputedStyle(document.documentElement).getPropertyValue(varName).trim()); } catch (e) { console.warn(`Could not parse CSS variable ${varName} as number.`); return 0; } }
        function angleToValue(angleDeg, valMin, valMax) { const physMin = config.DIAL_ANGLE_PHYSICAL_MIN; const range = config.DIAL_TOTAL_ANGLE_RANGE; angleDeg = (angleDeg % 360 + 360) % 360; let normalizedAngle = angleDeg - physMin; if (normalizedAngle < -config.EPSILON) { normalizedAngle += 360; } normalizedAngle = clamp(normalizedAngle, 0, range); return mapRange(normalizedAngle, 0, range, valMin, valMax); }
        function valueToAngle(value, valMin, valMax) { const physMin = config.DIAL_ANGLE_PHYSICAL_MIN; const range = config.DIAL_TOTAL_ANGLE_RANGE; value = clamp(value, valMin, valMax); const normalizedAngle = mapRange(value, valMin, valMax, 0, range); let physicalAngle = (physMin + normalizedAngle) % 360; return physicalAngle; }
        function angleToValue360(a, valMin, valMax) { a = (a % 360 + 360) % 360; return mapRange(a, 0, 360, valMin, valMax); }
        function valueToAngle360(v, valMin, valMax) { v = clamp(v, valMin, valMax); return mapRange(v, valMin, valMax, 0, 360); }
        function formatOklch(lcha, hue = null) { if (typeof lcha === 'string') return lcha; if (!lcha || typeof lcha.l !== 'number' || typeof lcha.c !== 'number') { console.warn("Invalid LCHA object:", lcha); return 'oklch(0 0 0)'; } const h = (typeof hue === 'number') ? hue.toFixed(1) : (typeof lcha.h === 'number' ? lcha.h.toFixed(1) : '0'); const l = lcha.l.toFixed(3); const c = lcha.c.toFixed(3); if (typeof lcha.a === 'number' && lcha.a < 1.0) { return `oklch(${l} ${c} ${h} / ${lcha.a.toFixed(2)})`; } else { return `oklch(${l} ${c} ${h})`; } }
        function getClampedAngle(angleDeg) { const physMin = config.DIAL_ANGLE_PHYSICAL_MIN; const physMax = config.DIAL_ANGLE_PHYSICAL_MAX; angleDeg = (angleDeg % 360 + 360) % 360; const isInDeadZone = angleDeg > physMax && angleDeg < physMin; if (isInDeadZone) { let distToMin = Math.abs(angleDeg - physMin); let distToMax = Math.abs(angleDeg - physMax); if (physMin > physMax) { distToMin = Math.min(Math.abs(angleDeg - physMin), Math.abs(angleDeg - physMin + 360)); distToMax = Math.min(Math.abs(angleDeg - physMax), Math.abs(angleDeg - physMax - 360)); } return distToMax <= distToMin ? physMax : physMin; } else { return angleDeg; } }
        function getPointOnCircle(cx, cy, radius, angleDeg) { const angleRad = angleDeg * constants.DEG_TO_RAD; return { x: cx + radius * Math.cos(angleRad), y: cy + radius * Math.sin(angleRad) }; }
        function getNextMessage(messageKey) { const messages = appMessages[messageKey]; if (!Array.isArray(messages) || messages.length === 0) { console.warn(`getNextMessage: No messages found for key '${messageKey}'`); return `[${messageKey}...]`; } const currentIndex = state.messageIndices[messageKey] || 0; const message = messages[currentIndex]; state.messageIndices[messageKey] = (currentIndex + 1) % messages.length; return message; }
        function calculateThemeGradientStops(themeName) { let l = 0.7, c = 0.12; if (themeName === 'saturated') { l = 0.70; c = 0.20; } else if (themeName === 'dark') { l = 0.70; c = 0.10; } const stops = []; const numStops = 12; for (let i = 0; i < numStops; i++) { const hue = (i * 360 / numStops); const percentage = (i / (numStops - 1)) * 100; stops.push(`oklch(${l.toFixed(3)} ${c.toFixed(3)} ${hue.toFixed(1)}) ${percentage.toFixed(2)}%`); } return stops; }
        function buildSliderTrackGradient(themeName) { try { const stops = calculateThemeGradientStops(themeName); return `linear-gradient(90deg, ${stops.join(', ')})`; } catch (error) { console.error("Error building slider gradient:", error); return 'linear-gradient(90deg, grey, lightgrey)'; } }
        function setDotFill(dot, newFillColor, animate = false, duration = 0.05, ease = 'none') { if (!dot || !dot.el) { console.warn("setDotFill: Invalid dot"); return; } if (animate) { gsap.to(dot.el, { fill: newFillColor, duration: duration, ease: ease, overwrite: true, onStart: () => { if (dot) dot.currentFill = newFillColor; } }); } else { gsap.set(dot.el, { fill: newFillColor }); dot.currentFill = newFillColor; } }
        function resetDotToInitialVisuals(dot, animate = true, duration = config.ANIMATION_DURATION_LEAVE, ease = 'power2.out') { if (!dot || !dot.el || typeof dot.cx !== 'number' || typeof dot.cy !== 'number' || !dot.initialFill) { console.warn("resetDotToInitialVisuals: Invalid dot"); return; } const targetState = { attr: { cx: dot.cx, cy: dot.cy }, fill: dot.initialFill }; if (animate) { gsap.to(dot.el, { attr: targetState.attr, fill: targetState.fill, duration: duration, ease: ease, overwrite: "auto", onStart: () => { if (dot) dot.currentFill = dot.initialFill; } }); } else { gsap.set(dot.el, targetState); dot.currentFill = dot.initialFill; } }
        function updateMessageBoxScroll() { const container = domRefs.consolePanel; if (container) { container.scrollTop = container.scrollHeight; } }
        function logMessage(newMessage) { if (!domRefs.messageBoxContent) return; state.messageLog.push(`> ${newMessage}`); if (state.messageLog.length > 3) { state.messageLog.shift(); } updateMessageBox(); }
        function updateMessageBox() { if (!domRefs.messageBoxContent) return; const typingSpeedFactor = 0.015; const maxTypingDuration = 1.5; if (domRefs.messageBoxContent.lastChild) { gsap.killTweensOf(domRefs.messageBoxContent.lastChild, "text"); } const fragment = document.createDocumentFragment(); let lastLineDiv = null; state.messageLog.forEach((line, index) => { const lineDiv = document.createElement('div'); const isLastMessage = index === state.messageLog.length - 1; const age = state.messageLog.length - 1 - index; lineDiv.style.opacity = age === 0 ? 1 : (age === 1 ? 0.7 : 0.4); if (isLastMessage) { lineDiv.textContent = ''; lastLineDiv = lineDiv; } else { lineDiv.textContent = line; } fragment.appendChild(lineDiv); }); domRefs.messageBoxContent.innerHTML = ''; domRefs.messageBoxContent.appendChild(fragment); if (lastLineDiv && state.messageLog.length > 0) { const lastLineText = state.messageLog[state.messageLog.length - 1]; const calculatedDuration = Math.min(lastLineText.length * typingSpeedFactor, maxTypingDuration); gsap.to(lastLineDiv, { text: { value: lastLineText, delimiter: "" }, duration: calculatedDuration, ease: "none", onUpdate: updateMessageBoxScroll, onComplete: updateMessageBoxScroll }); } else { updateMessageBoxScroll(); } }
        function getHueCategory(hueValue) { const hue = (hueValue % 360 + 360) % 360; for (const color in config.HUE_RANGES) { const range = config.HUE_RANGES[color]; if (hue >= range.min && hue < range.max) { return range.key; } } if (Math.abs(hue - 360) < config.EPSILON || Math.abs(hue - 0) < config.EPSILON) { if (config.HUE_RANGES.red?.key) { return config.HUE_RANGES.red.key; } } console.warn(`getHueCategory: Hue ${hue.toFixed(2)} did not fall into any defined range.`); let closestKey = null; let minDist = 360; for (const color in config.HUE_RANGES) { const range = config.HUE_RANGES[color]; const dist = Math.min(Math.abs(hue - range.min), Math.abs(hue - range.max)); if (dist < minDist) { minDist = dist; closestKey = range.key; } } return closestKey; }
        function logHueChange(initialHue, finalHue) { const hueDiff = Math.abs(finalHue - initialHue); if (hueDiff >= config.HUE_CHANGE_THRESHOLD || getHueCategory(finalHue) !== getHueCategory(initialHue)) { const colorCategoryKey = getHueCategory(finalHue); if (colorCategoryKey) { logMessage(getNextMessage(colorCategoryKey)); } } }

        // ==========================================================================
        // 6. Data Definitions
        // ==========================================================================
        const dotCoordinates = [ [6, 6], [6, 26], [6, 46], [6, 66], [6, 86], [26, 6], [26, 26], [26, 46], [26, 66], [26, 86], [46, 6], [46, 26], [46, 46], [46, 66], [46, 86], [66, 6], [66, 26], [66, 46], [66, 66], [66, 86], [86, 6], [86, 26], [86, 46], [86, 66], [86, 86], [86, 166], [86, 186], [86, 206], [86, 226], [86, 246], [86, 266], [86, 286], [86, 306], [86, 326], [86, 346], [86, 366], [86, 386], [86, 406], [86, 426], [86, 446], [106, 6], [106, 26], [106, 46], [106, 66], [106, 86], [106, 166], [106, 186], [106, 206], [106, 226], [106, 246], [106, 266], [106, 286], [106, 306], [106, 326], [106, 346], [106, 366], [106, 386], [106, 406], [106, 426], [106, 446], [126, 6], [126, 26], [126, 46], [126, 66], [126, 86], [126, 146], [126, 166], [126, 186], [126, 206], [126, 226], [126, 246], [126, 266], [126, 286], [126, 306], [126, 326], [126, 346], [126, 366], [126, 386], [126, 406], [126, 426], [126, 446], [146, 6], [146, 26], [146, 46], [146, 66], [146, 86], [146, 146], [146, 166], [146, 186], [146, 206], [146, 226], [146, 246], [146, 266], [146, 286], [146, 306], [146, 326], [146, 346], [146, 366], [146, 386], [146, 406], [146, 426], [146, 446], [166, 6], [166, 26], [166, 46], [166, 66], [166, 86], [166, 126], [166, 146], [166, 166], [166, 186], [166, 206], [166, 226], [166, 246], [166, 266], [166, 286], [166, 306], [166, 326], [166, 346], [166, 366], [166, 386], [166, 406], [166, 426], [166, 446], [186, 6], [186, 26], [186, 46], [186, 66], [186, 86], [186, 366], [186, 386], [186, 406], [186, 426], [186, 446], [206, 6], [206, 26], [206, 46], [206, 66], [206, 86], [206, 366], [206, 386], [206, 406], [206, 426], [206, 446], [226, 6], [226, 26], [226, 46], [226, 66], [226, 86], [226, 366], [226, 386], [226, 406], [226, 426], [226, 446], [246, 6], [246, 26], [246, 46], [246, 66], [246, 86], [246, 366], [246, 386], [246, 406], [246, 426], [246, 446], [266, 6], [266, 26], [266, 46], [266, 66], [266, 86], [266, 366], [266, 386], [266, 406], [266, 426], [266, 446], [286, 6], [286, 26], [286, 46], [286, 66], [286, 86], [286, 366], [286, 386], [286, 406], [286, 426], [286, 446], [306, 6], [306, 26], [306, 46], [306, 66], [306, 86], [306, 366], [306, 386], [306, 406], [306, 426], [306, 446], [326, 446], [326, 26], [326, 6], [326, 46], [326, 66], [326, 86], [326, 106], [326, 346], [326, 366], [326, 386], [326, 406], [326, 426], [346, 26], [346, 46], [346, 66], [346, 86], [346, 106], [346, 126], [346, 326], [346, 346], [346, 366], [346, 386], [346, 406], [346, 426], [366, 26], [366, 46], [366, 66], [366, 86], [366, 106], [366, 126], [366, 146], [366, 306], [366, 326], [366, 346], [366, 366], [366, 386], [366, 406], [366, 426], [386, 46], [386, 66], [386, 86], [386, 106], [386, 126], [386, 146], [386, 166], [386, 186], [386, 206], [386, 226], [386, 246], [386, 266], [386, 286], [386, 306], [386, 326], [386, 346], [386, 366], [386, 386], [386, 406], [406, 46], [406, 66], [406, 86], [406, 106], [406, 126], [406, 146], [406, 166], [406, 186], [406, 206], [406, 226], [406, 246], [406, 266], [406, 286], [406, 306], [406, 326], [406, 346], [406, 366], [406, 386], [406, 406], [426, 66], [426, 86], [426, 106], [426, 126], [426, 146], [426, 166], [426, 186], [426, 206], [426, 226], [426, 246], [426, 266], [426, 286], [426, 306], [426, 326], [426, 346], [426, 366], [426, 386], [446, 106], [446, 126], [446, 146], [466, 146], [446, 166], [446, 186], [446, 206], [446, 226], [446, 246], [446, 266], [446, 286], [446, 306], [466, 306], [446, 326], [446, 346], [466, 166], [466, 186], [466, 206], [466, 226], [466, 246], [466, 266], [466, 286] ];
        const DATA_BOUNDS = { minX: 6, minY: 6, maxX: 466, maxY: 446, width: 460, height: 440 };
        const dotRadiusInitial = config.DOT_DIAMETER_INITIAL / 2;
        const dialConfigs = { waveDirection: { stateProp: 'waveDirectionAngle', displayMin: config.DIAL_ANGLE_MIN, displayMax: config.DIAL_ANGLE_MAX, internalMin: config.DIAL_ANGLE_MIN, internalMax: config.DIAL_ANGLE_MAX, formatFn: formatInt, fullRange: true, needsEffectRestart: true, needsSvgRecalc: false }, waveSize: { stateProp: 'waveSizeIncrease', displayMin: config.DIAL_WAVE_SIZE_MIN, displayMax: config.DIAL_WAVE_SIZE_MAX, internalMin: config.WAVE_SIZE_INTERNAL_MIN, internalMax: config.WAVE_SIZE_INTERNAL_MAX, formatFn: formatFloat, fullRange: false, needsEffectRestart: true, needsSvgRecalc: false }, sparkleFreq: { stateProp: 'sparkleFrequency', displayMin: config.DIAL_SPARKLE_FREQ_MIN, displayMax: config.DIAL_SPARKLE_FREQ_MAX, internalMin: config.DIAL_SPARKLE_FREQ_MIN, internalMax: config.DIAL_SPARKLE_FREQ_MAX, formatFn: formatFloat, fullRange: false, needsEffectRestart: true, needsSvgRecalc: false }, sparkleSize: { stateProp: 'sparkleSizeIncrease', displayMin: config.DIAL_SPARKLE_SIZE_MIN, displayMax: config.DIAL_SPARKLE_SIZE_MAX, internalMin: config.SPARKLE_SIZE_INTERNAL_MIN, internalMax: config.SPARKLE_SIZE_INTERNAL_MAX, formatFn: formatFloat, fullRange: false, needsEffectRestart: true, needsSvgRecalc: false }, hoverFalloff: { stateProp: 'hoverFalloff', displayMin: config.DIAL_FALLOFF_MIN, displayMax: config.DIAL_FALLOFF_MAX, internalMin: config.DIAL_FALLOFF_MIN, internalMax: config.DIAL_FALLOFF_MAX, formatFn: formatInt, fullRange: false, needsEffectRestart: false, needsSvgRecalc: true }, hoverPower: { stateProp: 'hoverPower', displayMin: config.DIAL_POWER_MIN, displayMax: config.DIAL_POWER_MAX, internalMin: config.HOVER_POWER_INTERNAL_MIN, internalMax: config.HOVER_POWER_INTERNAL_MAX, formatFn: formatFloat, fullRange: false, needsEffectRestart: false, needsSvgRecalc: true } };

        // ==========================================================================
        // 7. Core Initialization Functions
        // ==========================================================================
        const $ = (selector, context = document) => { const el = context.querySelector(selector); if (!el) throw new Error(`Element not found: ${selector}`); return el; };
        const $$ = (selector, context = document) => context.querySelectorAll(selector);
        function populateDomRefs() { const refMap = { masterPanelWrapper: '#master-panel-wrapper', messageBoxContent: '#message-box-content', masterToggle: '#master-toggle', themeToggle: '#theme-toggle', hueSliderContainer: '#hue-slider-container', hueTrack: '#hue-track', hueThumbContainer: '#hue-thumb-container', hueThumb: '#hue-thumb', thumbIcon: '#thumb-icon', hueHoverLine: '#hue-hover-line', masterTitle: '#master-title', logoSvg: '#dfx-logo-svg', svgElement: '#interactive-svg', svgContainer: '#svg-container', displaySection: '#display-section', tapButton: '#tap-button', jiggleButton: '#jiggle-button', waveTapButton: '#wave-tap-button', effectTypeToggle: '#effect-type-toggle', hoverTypeToggle: '#hover-type-toggle', consolePanel: '#console-panel', messageBoxContainer: '#message-box-container', footerContainer: '#footer-container', footerCredit: '#footer-credit', waveControls: '#effect-dials .dial-container[data-effect-type="wave"]', sparkleControls: '#effect-dials .dial-container[data-effect-type="sparkle"]', logoElements: '#dfx-logo-svg path, #dfx-logo-svg rect', }; let allRefsFound = true; for (const key in refMap) { try { const isMultiple = ['waveControls', 'sparkleControls', 'logoElements'].includes(key); domRefs[key] = isMultiple ? $$(refMap[key]) : $(refMap[key]); } catch (error) { console.error(`DOM Ref Error: ${error.message}`); domRefs[key] = null; allRefsFound = false; } } $$('[data-dial-id]').forEach(el => { domRefs[`dial_${el.dataset.dialId}`] = el; }); $$('[data-value-id]').forEach(el => { domRefs[`value_${el.dataset.valueId}`] = el; }); $$('.dial-indicator-group').forEach(el => { const dial = el.closest('.dial-svg'); if (dial && dial.dataset.dialId) { domRefs[`indicator_${dial.dataset.dialId}`] = el; } }); const criticalKeys = ['masterPanelWrapper', 'svgElement', 'svgContainer', 'masterToggle', 'themeToggle', 'hueSliderContainer', 'logoSvg', 'messageBoxContent']; criticalKeys.forEach(key => { if (!domRefs[key]) { console.error(`Critical DOM Ref Missing: ${key}`); allRefsFound = false; } }); Object.keys(dialConfigs).forEach(id => { if (!domRefs[`dial_${id}`] || !domRefs[`indicator_${id}`] || !domRefs[`value_${id}`]) { console.warn(`DOM Ref Warning: Missing elements for dial '${id}'.`); } }); if (!allRefsFound) { throw new Error("One or more critical DOM elements required for initialization are missing."); } return true; }
        function createGridLines() { if (!domRefs.svgElement) return; const existingGroup = domRefs.svgElement.querySelector('#grid-lines-group'); if (existingGroup) existingGroup.remove(); const gridGroup = createSvgElement('g', { id: 'grid-lines-group' }); const spacing = config.GRID_SPACING; const uniqueX = [...new Set(dotCoordinates.map(p => p[0]))].sort((a, b) => a - b); const uniqueY = [...new Set(dotCoordinates.map(p => p[1]))].sort((a, b) => a - b); const outerLineXBefore = DATA_BOUNDS.minX - spacing; const outerLineXAfter = DATA_BOUNDS.maxX + spacing; const outerLineYBefore = DATA_BOUNDS.minY - spacing; const outerLineYAfter = DATA_BOUNDS.maxY + spacing; const allXCoords = [...new Set([outerLineXBefore, ...uniqueX, outerLineXAfter])].sort((a, b) => a - b); const allYCoords = [...new Set([outerLineYBefore, ...uniqueY, outerLineYAfter])].sort((a, b) => a - b); allXCoords.forEach(x => { gridGroup.appendChild(createSvgElement('line', { x1: x, y1: outerLineYBefore, x2: x, y2: outerLineYAfter })); }); allYCoords.forEach(y => { gridGroup.appendChild(createSvgElement('line', { x1: outerLineXBefore, y1: y, x2: outerLineXAfter, y2: y })); }); domRefs.svgElement.prepend(gridGroup); }
        function setupSvg() { if (!domRefs.svgElement || !state || !geometry) { console.error("setupSvg: Missing critical refs."); return; } const viewBoxWidth = DATA_BOUNDS.width + config.VIEWBOX_PADDING_UNITS * 2; const viewBoxHeight = DATA_BOUNDS.height + config.VIEWBOX_PADDING_UNITS * 2; geometry.scaleFactor = config.TARGET_SVG_WIDTH > 0 ? config.TARGET_SVG_WIDTH / viewBoxWidth : 1; geometry.viewBoxParams = { x: DATA_BOUNDS.minX - config.VIEWBOX_PADDING_UNITS, y: DATA_BOUNDS.minY - config.VIEWBOX_PADDING_UNITS, width: viewBoxWidth, height: viewBoxHeight }; domRefs.svgElement.setAttribute('viewBox', `${geometry.viewBoxParams.x} ${geometry.viewBoxParams.y} ${geometry.viewBoxParams.width} ${geometry.viewBoxParams.height}`); geometry.gridCenter.x = DATA_BOUNDS.minX + DATA_BOUNDS.width / 2; geometry.gridCenter.y = DATA_BOUNDS.minY + DATA_BOUNDS.height / 2; createGridLines(); if (!domRefs.cursorGravityCircle) { domRefs.cursorGravityCircle = createSvgElement('circle', { id: 'cursor-gravity-circle', class: 'cursor-circle', r: 10 }); domRefs.svgElement.appendChild(domRefs.cursorGravityCircle); } requestAnimationFrame(() => { try { geometry.svgRect = domRefs.svgElement.getBoundingClientRect(); } catch(rAFError) { console.error("Error inside setupSvg rAF callback getting initial rect:", rAFError); } }); }
        function createDots(initialFillColor, hoverFillColor) { if (typeof dotRadiusInitial !== 'number' || isNaN(dotRadiusInitial) || dotRadiusInitial <= 0 || !domRefs.svgElement || !Array.isArray(dotCoordinates) || !gsap) { console.error("createDots: Preconditions failed."); return; } if (typeof initialFillColor !== 'string' || !initialFillColor) { console.error(`createDots: Invalid initialFillColor: ${initialFillColor}. Using fallback.`); initialFillColor = '#FF0000'; } if (typeof hoverFillColor !== 'string' || !hoverFillColor) { console.warn(`createDots: Invalid hoverFillColor: ${hoverFillColor}. Using initial.`); hoverFillColor = initialFillColor; } stopCurrentEffect(); state.dots.forEach(dot => { if (dot?.el) { gsap.killTweensOf(dot.el); dot.el.remove(); } }); state.dots = []; const fragment = document.createDocumentFragment(); dotCoordinates.forEach((coord, index) => { if (!Array.isArray(coord) || coord.length < 2 || typeof coord[0] !== 'number' || typeof coord[1] !== 'number') { console.warn(`createDots: Skipping invalid coord ${index}:`, coord); return; } const [x, y] = coord; const circle = createSvgElement('circle', { cx: x, cy: y, r: dotRadiusInitial, fill: initialFillColor }); circle.dataset.cx = x; circle.dataset.cy = y; circle.dataset.initialR = dotRadiusInitial; fragment.appendChild(circle); state.dots.push({ el: circle, initialR: dotRadiusInitial, initialFill: initialFillColor, hoverFill: hoverFillColor, currentFill: initialFillColor, cx: x, cy: y }); }); domRefs.svgElement.appendChild(fragment); }
        function createTicks(dialSvgElement, isFullRange) { const cx = 20, cy = 20; const innerRadius = 18 + 8; const outerRadius = innerRadius + 8; const decorationsGroup = dialSvgElement.querySelector('.dial-decorations'); if (!decorationsGroup) return; decorationsGroup.innerHTML = ''; const fragment = document.createDocumentFragment(); const thickStrokeWidth = '2'; const thinStrokeWidth = '1'; const cardinalAngles = [0, 90, 180, 270]; let tickAngles = isFullRange ? [0, 30, 60, 90, 120, 150, 180, 210, 240, 270, 300, 330] : [120, 150, 180, 210, 240, 270, 300, 330, 0, 30, 60]; tickAngles.forEach(angle => { const p1 = getPointOnCircle(cx, cy, innerRadius, angle); const p2 = getPointOnCircle(cx, cy, outerRadius, angle); let strokeWidth = thinStrokeWidth; if (isFullRange) { if (cardinalAngles.includes(angle)) strokeWidth = thickStrokeWidth; } else { const isMin = Math.abs(angle - config.DIAL_ANGLE_PHYSICAL_MIN) < config.EPSILON; const isMax = Math.abs(angle - config.DIAL_ANGLE_PHYSICAL_MAX) < config.EPSILON; if (isMin || isMax) strokeWidth = thickStrokeWidth; } const tick = createSvgElement('line', { x1: p1.x, y1: p1.y, x2: p2.x, y2: p2.y, class: 'dial-division', 'stroke-width': strokeWidth }); fragment.appendChild(tick); }); decorationsGroup.appendChild(fragment); }
        function initializeDial(dialId) { const dConfig = dialConfigs[dialId]; const dialEl = domRefs[`dial_${dialId}`]; const indicatorEl = domRefs[`indicator_${dialId}`]; const valueEl = domRefs[`value_${dialId}`]; if (!dConfig || !dialEl || !indicatorEl || !valueEl) { if (valueEl) valueEl.textContent = 'Err'; return; } createTicks(dialEl, dConfig.fullRange); const stateVal = state[dConfig.stateProp]; if (typeof stateVal !== 'number' || typeof dConfig.displayMin !== 'number' || typeof dConfig.displayMax !== 'number') { console.warn(`initializeDial: Invalid state/config value for dial '${dialId}'.`); valueEl.textContent = 'Err'; return; } dialEl.dataset.dialId = dialId; dialEl.dataset.min = dConfig.displayMin; dialEl.dataset.max = dConfig.displayMax; dialEl.dataset.format = (dConfig.formatFn === formatFloat) ? 'float' : 'int'; const displayValue = mapRange(stateVal, dConfig.internalMin, dConfig.internalMax, dConfig.displayMin, dConfig.displayMax); const initialAngle = dConfig.fullRange ? valueToAngle360(displayValue, dConfig.displayMin, dConfig.displayMax) : valueToAngle(displayValue, dConfig.displayMin, dConfig.displayMax); updateDialVisuals(dialEl, indicatorEl, valueEl, initialAngle, dConfig.formatFn); }
        function initializeToggle(toggleContainerRef, activeValue, dataAttributeKey) { if (!toggleContainerRef) { console.warn(`initializeToggle: Invalid container ref for key '${dataAttributeKey}'.`); return; } const buttons = toggleContainerRef.querySelectorAll('button'); buttons.forEach(btn => { btn.classList.toggle('active', btn.dataset[dataAttributeKey] === activeValue); }); }
        function initializeControls() { if (!domRefs.effectTypeToggle || !domRefs.hoverTypeToggle || !domRefs.themeToggle) { console.error("initializeControls: Missing toggle refs."); return; } Object.keys(dialConfigs).forEach(dialId => { initializeDial(dialId); }); initializeToggle(domRefs.effectTypeToggle, state.activeEffect, 'effectType'); initializeToggle(domRefs.hoverTypeToggle, state.activeHoverMode, 'hoverType'); initializeToggle(domRefs.themeToggle, state.currentTheme, 'theme'); applyTheme(state.currentTheme, false); updateEffectDialsVisibility(); const hoverPowerLabel = document.getElementById('hover-power-label'); if (hoverPowerLabel) hoverPowerLabel.textContent = "Power"; }

        // ==========================================================================
        // 8. Theme Management Functions
        // ==========================================================================
        function updateThemeColors(updateDots = true) { const root = document.documentElement; const rootStyle = root.style; const currentThemeDef = themes[state.currentTheme]; const hue = state.brandHue; const cssVariablesToSet = { '--brand-hue': hue.toFixed(1) }; const setVar = (varName, value) => { if (value !== undefined && value !== null) cssVariablesToSet[varName] = value; }; const bodyBgDef = currentThemeDef.bodyBg; setVar('--body-bg-color', bodyBgDef ? formatOklch(bodyBgDef, bodyBgDef.hueSensitive ? hue : bodyBgDef.h) : 'oklch(1 0 0)'); setVar('--slider-track-gradient', buildSliderTrackGradient(state.currentTheme)); let calculatedDotRestingColor, calculatedDotHoverColor; if (state.currentTheme === 'saturated') { const baseDotLC = currentThemeDef.accent; calculatedDotRestingColor = formatOklch(baseDotLC, hue); const hoverL = Math.min(1.0, baseDotLC.l + config.SATURATED_HOVER_LIGHTNESS_INCREASE); const hoverC = baseDotLC.c + config.SATURATED_HOVER_CHROMA_INCREASE; calculatedDotHoverColor = formatOklch({ l: hoverL, c: hoverC }, hue); } else { calculatedDotRestingColor = currentThemeDef.dotRestingColor; calculatedDotHoverColor = formatOklch(currentThemeDef.dotHover, hue); if (typeof calculatedDotRestingColor !== 'string') { calculatedDotRestingColor = (state.currentTheme === 'dark') ? '#E0E0E0' : '#333333'; console.warn("Used fallback dotRestingColor"); } } setVar('--dot-resting-color', calculatedDotRestingColor); setVar('--dot-hover-color', calculatedDotHoverColor); const bombRingDef = currentThemeDef.bombRing; state.currentRingHue = (bombRingDef && typeof bombRingDef === 'object' && bombRingDef.hueSensitive) ? hue : (bombRingDef?.h ?? hue); const keyToVarMap = { bodyTextColor: '--body-text-color', panelBgBase: '--panel-bg-base', panelBgElevated: '--panel-bg-elevated', panelBgSunken: '--panel-bg-sunken', panelBorder: '--panel-border-color', panelText: '--panel-text-color', panelLabel: '--panel-label-color', toggleActiveText: '--toggle-active-text', toggleInactiveText: '--toggle-inactive-text', dialBaseStroke: '--dial-base-stroke', gridLine: '--grid-line-color', dotSleep: '--dot-sleep-color', accent: '--accent-color', interactiveBg: '--interactive-bg', interactiveBgHover: '--interactive-bg-hover', interactiveBgPressed: '--interactive-bg-pressed', svgBg: '--svg-bg-color', themeIconLightFill: '--theme-icon-light-fill', themeIconLightStroke: '--theme-icon-light-stroke', themeIconSaturatedFill: '--theme-icon-saturated-fill', themeIconSaturatedStroke: '--theme-icon-saturated-stroke', themeIconDarkFill: '--theme-icon-dark-fill', themeIconDarkStroke: '--theme-icon-dark-stroke', faintControlText: '--faint-control-text', secondaryText: '--secondary-text', masterPanelBorder: '--master-panel-border-color', masterPanelBg: '--master-panel-bg-color', }; for (const themeKey in currentThemeDef) { const cssVarName = keyToVarMap[themeKey]; if (cssVarName) { const valueDef = currentThemeDef[themeKey]; let cssValue = null; if (typeof valueDef === 'object' && valueDef !== null && typeof valueDef.l === 'number') { const effectiveHue = valueDef.hueSensitive ? hue : (valueDef.h ?? null); cssValue = formatOklch(valueDef, effectiveHue); } else if (typeof valueDef === 'string') { cssValue = valueDef; } setVar(cssVarName, cssValue); } } for (const varName in cssVariablesToSet) { rootStyle.setProperty(varName, cssVariablesToSet[varName]); } if (updateDots && Array.isArray(state.dots)) { state.dots.forEach(dot => { if (dot && dot.el) { const wasHoverFill = dot.currentFill === dot.hoverFill; dot.initialFill = calculatedDotRestingColor; dot.hoverFill = calculatedDotHoverColor; if (!wasHoverFill) { setDotFill(dot, calculatedDotRestingColor, false); } } }); } if (calculatedDotRestingColor) { setVar('--console-text-color', calculatedDotRestingColor); rootStyle.setProperty('--console-text-color', calculatedDotRestingColor); if (domRefs.messageBoxContent) { domRefs.messageBoxContent.style.color = calculatedDotRestingColor; } } }
        function applyTheme(themeName, startEffect = true) { const newThemeDef = themes[themeName] || themes.light; const body = document.body; stopCurrentEffect(); state.dots.forEach(dot => { if (dot?.el) gsap.killTweensOf(dot.el); }); body.classList.remove('dark-theme', 'saturated-theme-active'); if (newThemeDef.cssClass) { body.classList.add(newThemeDef.cssClass); } state.currentTheme = themeName; updateThemeColors(true); let targetInitialFill = getComputedStyle(document.documentElement).getPropertyValue('--dot-resting-color').trim(); let targetHoverFill = getComputedStyle(document.documentElement).getPropertyValue('--dot-hover-color').trim(); if (!targetInitialFill) { targetInitialFill = (themeName === 'dark') ? '#E0E0E0' : '#333333'; console.warn("Fallback used for targetInitialFill"); } if (!targetHoverFill) { targetHoverFill = targetInitialFill; console.warn("Fallback used for targetHoverFill"); } createDots(targetInitialFill, targetHoverFill); setHueSliderPosition((state.brandHue / 360) * 100, state.brandHue, false); if (startEffect && state.masterMode === 'activated') { startCurrentEffect(); } }

        // ==========================================================================
        // 9. Animation Control Functions (Background Effects)
        // ==========================================================================
        function stopSparkleAnimation() { if (Array.isArray(state.sparkleTweens) && state.sparkleTweens.length > 0) { state.sparkleTweens.forEach(tween => tween?.kill()); state.sparkleTweens = []; } }
        function startSparkleAnimation() { if (state.masterMode === 'sleep' || state.activeEffect !== 'sparkle' || !gsap || !Array.isArray(state.dots) || state.dots.length === 0) return; stopSparkleAnimation(); const freq = Math.max(config.EPSILON, state.sparkleFrequency || 1); const internalSize = state.sparkleSizeIncrease; const baseDuration = config.SPARKLE_BASE_DURATION / freq; const baseDelay = config.SPARKLE_BASE_DELAY / freq; const maxRadius = dotRadiusInitial + internalSize; state.dots.forEach((dot, index) => { if (!dot || !(dot.el instanceof SVGElement) || typeof dot.initialR !== 'number') { console.warn(`startSparkleAnimation: Skipping invalid dot ${index}`); return; } try { gsap.set(dot.el, { attr: { r: dot.initialR }, fill: dot.initialFill }); dot.currentFill = dot.initialFill; const tween = gsap.to(dot.el, { attr: { r: () => gsap.utils.random(dot.initialR, maxRadius) }, duration: () => gsap.utils.random(config.SPARKLE_MIN_DURATION_FACTOR, config.SPARKLE_MAX_DURATION_FACTOR) * baseDuration, delay: () => gsap.utils.random(config.SPARKLE_MIN_DELAY_FACTOR, config.SPARKLE_MAX_DELAY_FACTOR) * baseDelay, ease: "power1.inOut", yoyo: true, repeat: -1, repeatRefresh: true, overwrite: "auto" }); state.sparkleTweens.push(tween); } catch (error) { console.error(`Error creating sparkle tween for dot ${index}:`, error); } }); }
        function stopWaveAnimation() { if (state.waveTimeline) { state.waveTimeline.kill(); state.waveTimeline = null; } }
        function startWaveAnimation() { if (state.masterMode === 'sleep' || state.activeEffect !== 'wave' || !gsap || !Array.isArray(state.dots) || state.dots.length === 0) return; stopWaveAnimation(); const internalSize = state.waveSizeIncrease; const dotRadiusWave = dotRadiusInitial + internalSize; const waveCrossDuration = config.BASE_WAVE_CROSS_DURATION / (config.INITIAL_WAVE_SPEED_FACTOR || 1); const angleRad = degreesToRadians(state.waveDirectionAngle); let minD = Infinity, maxD = -Infinity, validDotsExist = false; state.dots.forEach(dot => { if (!dot || typeof dot.cx !== 'number' || typeof dot.cy !== 'number') return; const d = getWaveDistanceMetric(dot.cx, dot.cy, angleRad); minD = Math.min(minD, d); maxD = Math.max(maxD, d); validDotsExist = true; }); if (!validDotsExist) { console.error("startWaveAnimation: No valid dots."); return; } const range = maxD - minD; if (range < config.EPSILON) { console.warn("startWaveAnimation: Wave range negligible."); } const dotElements = state.dots.map(d => d?.el).filter(el => el instanceof SVGElement); if (dotElements.length === 0) { console.error("startWaveAnimation: No valid SVG dots."); return; } dotElements.forEach((el) => { const dot = state.dots.find(d => d?.el === el); if (dot) { gsap.set(el, { attr: { r: dot.initialR }, fill: dot.initialFill }); dot.currentFill = dot.initialFill; } }); state.waveTimeline = gsap.timeline({ repeat: -1, repeatDelay: config.WAVE_REPEAT_DELAY, onKill: () => { state.waveTimeline = null; } }); const staggerFn = (index, target) => { const dot = state.dots.find(d => d?.el === target); if (!dot || typeof dot.cx !== 'number' || typeof dot.cy !== 'number') return 0; const d = getWaveDistanceMetric(dot.cx, dot.cy, angleRad); return range > config.EPSILON ? ((d - minD) / range) * waveCrossDuration : 0; }; try { state.waveTimeline.to(dotElements, { attr: { r: dotRadiusWave }, duration: config.WAVE_EXPAND_DURATION, ease: "sine.out", stagger: staggerFn }, 0).to(dotElements, { attr: { r: dotRadiusInitial }, duration: config.WAVE_SHRINK_DURATION, ease: "sine.in", stagger: staggerFn }, `+=${config.WAVE_SHRINK_DELAY}`); } catch (error) { console.error("Error creating wave tweens:", error); stopWaveAnimation(); } }
        function stopCurrentEffect() { if (state.activeEffect === 'wave') stopWaveAnimation(); else if (state.activeEffect === 'sparkle') stopSparkleAnimation(); }
        function startCurrentEffect() { if (state.masterMode !== 'activated') return; if (state.activeEffect === 'wave') startWaveAnimation(); else if (state.activeEffect === 'sparkle') startSparkleAnimation(); }

        // ==========================================================================
        // 10. Interaction Effect Functions (Tap Effects)
        // ==========================================================================
        function triggerPopEffect() { // Pop effect from button press (random subset)
            if (state.masterMode === 'sleep' || !gsap || !state || !domRefs.svgElement || !state.dots.length) return;
            const currentThemeDef = themes[state.currentTheme];
            if (!currentThemeDef?.bombRing) { console.error("Bomb ring color definition not found."); return; }

            // Removed stop/start of background effect
            logMessage(getNextMessage('bomb'));

            const bombRingBase = currentThemeDef.bombRing;
            const popColor = formatOklch(bombRingBase, state.currentRingHue);
            state.currentRingHue = (state.currentRingHue + config.RING_HUE_INCREMENT) % 360;

            const shuffledDots = [...state.dots].sort(() => 0.5 - Math.random());
            const targetCount = Math.floor(shuffledDots.length * 0.33);
            const targetDots = shuffledDots.slice(0, targetCount);
            const fragment = document.createDocumentFragment();
            let animationsToComplete = targetDots.length;

            if (targetDots.length === 0) return; // No dots to pop

            const onRingComplete = (ring) => {
                ring.remove();
                animationsToComplete--;
            };

            targetDots.forEach((dot, index) => {
                if (!dot || !(dot.el instanceof SVGElement) || typeof dot.cx !== 'number' || typeof dot.cy !== 'number') {
                    console.warn(`triggerPopEffect: Skipping invalid dot ${index}.`);
                    animationsToComplete--;
                    return;
                }
                const ring = createSvgElement('circle', { cx: dot.cx, cy: dot.cy, r: dotRadiusInitial, stroke: popColor, 'stroke-width': config.POP_STROKE_WIDTH, class: 'pop-ring' });
                fragment.appendChild(ring);
                gsap.fromTo(ring,
                    { attr: { r: dotRadiusInitial }, opacity: config.POP_INITIAL_OPACITY },
                    { attr: { r: config.POP_FINAL_RADIUS }, opacity: 0, duration: config.POP_DURATION, ease: "power2.out", onComplete: () => onRingComplete(ring) }
                );
            });
            domRefs.svgElement.appendChild(fragment);
        }

        function triggerPopEffectAtPoint(svgX, svgY) { // Pop effect at a specific point (SVG click)
            if (state.masterMode === 'sleep' || !gsap || !state || !domRefs.svgElement) return;
            const currentThemeDef = themes[state.currentTheme];
            if (!currentThemeDef?.bombRing) { console.error("Bomb ring color definition not found for point pop."); return; }

            // Removed stop/start of background effect

            const bombRingBase = currentThemeDef.bombRing;
            const popColor = formatOklch(bombRingBase, state.currentRingHue);
            state.currentRingHue = (state.currentRingHue + config.RING_HUE_INCREMENT) % 360;

            const numPops = 1; // Just one pop for a click
            let animationsToComplete = numPops;
            const fragment = document.createDocumentFragment();

             const onRingComplete = (ring) => {
                ring.remove();
                animationsToComplete--;
            };

            for (let i = 0; i < numPops; i++) {
                const randX = svgX; // Center pop on click
                const randY = svgY;
                const ring = createSvgElement('circle', { cx: randX, cy: randY, r: dotRadiusInitial, stroke: popColor, 'stroke-width': config.POP_STROKE_WIDTH, class: 'pop-ring' });
                fragment.appendChild(ring);
                gsap.fromTo(ring,
                    { attr: { r: dotRadiusInitial }, opacity: config.POP_INITIAL_OPACITY },
                    { attr: { r: config.POP_FINAL_RADIUS }, opacity: 0, duration: config.POP_DURATION, ease: "power2.out", onComplete: () => onRingComplete(ring) }
                );
            }
            domRefs.svgElement.appendChild(fragment);
        }

        function triggerShakeEffect() {
            if (state.masterMode === 'sleep' || !gsap || !Array.isArray(state.dots) || state.dots.length === 0) return;
            logMessage(getNextMessage('shake'));
            stopCurrentEffect(); // Stop background effect for shake, as it modifies positions heavily

            const shakeAmount = config.SHAKE_AMOUNT;
            const partDuration = config.SHAKE_DURATION / 3;
            let timelinesComplete = 0;
            const validDots = state.dots.filter(dot => dot && dot.el instanceof SVGElement && typeof dot.cx === 'number' && typeof dot.cy === 'number');
            if (validDots.length === 0) { startCurrentEffect(); return; }

            const completionHandler = () => { timelinesComplete++; if (timelinesComplete === validDots.length) { startCurrentEffect(); } }; // Restart background effect on completion

            validDots.forEach((dot) => {
                gsap.killTweensOf(dot.el, "attr");
                const tl = gsap.timeline({ delay: gsap.utils.random(0, config.SHAKE_DELAY_MAX), onComplete: completionHandler });
                const randX1 = dot.cx + gsap.utils.random(-shakeAmount, shakeAmount); const randY1 = dot.cy + gsap.utils.random(-shakeAmount, shakeAmount);
                const randX2 = dot.cx + gsap.utils.random(-shakeAmount, shakeAmount); const randY2 = dot.cy + gsap.utils.random(-shakeAmount, shakeAmount);
                tl.to(dot.el, { attr: { cx: randX1, cy: randY1 }, duration: partDuration, ease: "power1.inOut" })
                  .to(dot.el, { attr: { cx: randX2, cy: randY2 }, duration: partDuration, ease: "power1.inOut" })
                  .to(dot.el, { attr: { cx: dot.cx, cy: dot.cy }, duration: partDuration, ease: "power1.inOut" });
            });
        }

        function triggerPulseEffect() {
            if (state.masterMode === 'sleep' || !gsap || !Array.isArray(state.dots) || state.dots.length === 0) return;
            logMessage(getNextMessage('pulse'));
            stopCurrentEffect(); // Stop background effect for pulse

            const dotElements = state.dots.map(d => d.el).filter(el => el instanceof SVGElement);
            if (dotElements.length === 0) { startCurrentEffect(); return; }

            const centerX = geometry.gridCenter.x; const centerY = geometry.gridCenter.y;
            let maxDist = 0; state.dots.forEach(dot => { const d = distance(centerX, centerY, dot.cx, dot.cy); if (d > maxDist) maxDist = d; });
            maxDist = Math.max(maxDist, config.EPSILON);

            gsap.killTweensOf(dotElements, "attr");
            gsap.to(dotElements, {
                duration: config.PULSE_DURATION / 2,
                attr: { r: (i, target) => (state.dots.find(d => d.el === target)?.initialR ?? dotRadiusInitial) + config.PULSE_MAX_RADIUS_INCREASE, cy: (i, target) => (state.dots.find(d => d.el === target)?.cy ?? 0) - config.PULSE_MAX_Y_DISPLACEMENT },
                ease: "power1.out", yoyo: true, repeat: 1,
                stagger: (index, target) => { const dotData = state.dots.find(d => d.el === target); if (!dotData) return 0; const dist = distance(centerX, centerY, dotData.cx, dotData.cy); return (dist / maxDist) * config.PULSE_TOTAL_STAGGER; },
                onComplete: () => { state.dots.forEach(dot => { if(dot) resetDotToInitialVisuals(dot, false); }); startCurrentEffect(); } // Restart background effect on completion
            });
        }

        // ==========================================================================
        // 11. Mouse/Touch Handling Functions (Hover Effects)
        // ==========================================================================
        function applyHoverEffect(svgX, svgY) { /* Uses config but doesn't stop/start bg effect */ if (!gsap || !Array.isArray(state.dots) || state.dots.length === 0 || !geometry.scaleFactor || geometry.scaleFactor <= 0) return; const hoverRadiusSVG = state.hoverFalloff / geometry.scaleFactor; const visualCursorRadiusSVG = hoverRadiusSVG / 2; if (domRefs.cursorGravityCircle) { gsap.set(domRefs.cursorGravityCircle, { attr: { cx: svgX, cy: svgY, r: visualCursorRadiusSVG } }); } state.dots.forEach(dot => { if (!dot || !dot.el || !dot.initialFill || !dot.hoverFill) return; const dx = svgX - dot.cx; const dy = svgY - dot.cy; const dist = Math.sqrt(dx * dx + dy * dy); const linearIntensity = clamp(1 - (dist / hoverRadiusSVG), 0, 1); const targetColor = linearIntensity > 0.01 ? dot.hoverFill : dot.initialFill; if (dot.currentFill !== targetColor) { setDotFill(dot, targetColor, false); } const shiftIntensity = linearIntensity; let targetCx = dot.cx; let targetCy = dot.cy; if (shiftIntensity > 0 && dist > config.EPSILON) { const powerInternal = state.hoverPower; const powerSVG = powerInternal / geometry.scaleFactor; const directionMultiplier = state.activeHoverMode === 'attract' ? 1 : -1; const shiftAmount = powerSVG * shiftIntensity; targetCx += (dx / dist) * shiftAmount * directionMultiplier; targetCy += (dy / dist) * shiftAmount * directionMultiplier; } gsap.to(dot.el, { attr: { cx: targetCx, cy: targetCy }, duration: config.ANIMATION_DURATION_HOVER_POS, ease: 'power1.out', overwrite: "auto" }); }); }
        function getSvgCoordinates(screenX, screenY) { if (!domRefs.svgElement) { console.error("getSvgCoordinates: SVG Element missing."); return null; } if (!geometry.ctmInverse) { try { const ctm = domRefs.svgElement.getScreenCTM(); if (ctm) geometry.ctmInverse = ctm.inverse(); if (!geometry.ctmInverse) throw new Error("Failed to invert CTM."); } catch (e) { console.error("Error getting/inverting CTM:", e); geometry.ctmInverse = null; return null; } } const pt = domRefs.svgElement.createSVGPoint(); pt.x = screenX; pt.y = screenY; try { return pt.matrixTransform(geometry.ctmInverse); } catch (e) { console.error("Error transforming coordinates:", e); geometry.ctmInverse = null; return null; } }
        function handleMouseEnter(event) { if (state.isDraggingSvg || !domRefs.svgElement || state.masterMode === 'sleep') return; state.isMouseOverSvg = true; if (state.masterMode === 'activated') { domRefs.svgElement.addEventListener('mousemove', handleMouseMove); } domRefs.svgElement.classList.add('mouse-over'); }
        function handleMouseMove(event) { if (state.isDraggingDial || state.isDraggingSvg || state.masterMode === 'sleep') return; const svgMousePoint = getSvgCoordinates(event.clientX, event.clientY); if (!svgMousePoint) return; applyHoverEffect(svgMousePoint.x, svgMousePoint.y); }
        function handleMouseLeave(event) { if (state.isDraggingSvg || !domRefs.svgElement) return; state.isMouseOverSvg = false; domRefs.svgElement.removeEventListener('mousemove', handleMouseMove); domRefs.svgElement.classList.remove('mouse-over'); if (state.masterMode !== 'sleep' && !state.isDraggingDial) { state.dots.forEach(dot => { if (dot?.el instanceof SVGElement && dot.initialFill) { resetDotToInitialVisuals(dot, true); } }); } }
        function handleTouchStart(e) { if (state.isDraggingDial || state.masterMode === 'sleep' || !e.touches || e.touches.length === 0) return; e.preventDefault(); state.isDraggingSvg = true; state.isMouseOverSvg = true; document.addEventListener('touchmove', handleTouchMove, { passive: false }); document.addEventListener('touchend', handleTouchEnd); document.addEventListener('touchcancel', handleTouchEnd); domRefs.svgElement.classList.add('mouse-over'); const touch = e.touches[0]; const svgTouchPoint = getSvgCoordinates(touch.clientX, touch.clientY); if (svgTouchPoint) { applyHoverEffect(svgTouchPoint.x, svgTouchPoint.y); } }
        function handleTouchMove(e) { if (!state.isDraggingSvg || state.isDraggingDial || state.masterMode === 'sleep' || !e.touches || e.touches.length === 0) return; e.preventDefault(); const touch = e.touches[0]; const svgTouchPoint = getSvgCoordinates(touch.clientX, touch.clientY); if (svgTouchPoint) { applyHoverEffect(svgTouchPoint.x, svgTouchPoint.y); } }
        function handleTouchEnd(e) { if (!state.isDraggingSvg) return; state.isDraggingSvg = false; state.isMouseOverSvg = false; document.removeEventListener('touchmove', handleTouchMove); document.removeEventListener('touchend', handleTouchEnd); document.removeEventListener('touchcancel', handleTouchEnd); domRefs.svgElement.classList.remove('mouse-over'); if (state.masterMode !== 'sleep') { state.dots.forEach(dot => { if (dot?.el instanceof SVGElement && dot.initialFill) { resetDotToInitialVisuals(dot, true); } }); } }
        function handleSvgClick(event) { if (state.masterMode === 'sleep' || event.pointerType !== 'mouse' || state.isDraggingDial) { return; } const svgClickPoint = getSvgCoordinates(event.clientX, event.clientY); if (svgClickPoint) { triggerPopEffectAtPoint(svgClickPoint.x, svgClickPoint.y); } } // Calls the modified triggerPopEffectAtPoint

        // ==========================================================================
        // 12. Master Mode Functions & Logo Animation
        // ==========================================================================
        function setSleepDimmedState(isDimmed) { document.body.classList.toggle('app-sleeping', isDimmed); const allControls = $$('#control-console-frame button, #control-console-frame input[type=range], #control-console-frame .hue-slider-track, #control-console-frame .hue-slider-thumb-container'); allControls.forEach(ctrl => { const isMasterOnButton = ctrl.closest('#master-toggle') && ctrl.dataset.masterMode === 'activated'; if (ctrl.tagName === 'BUTTON' || ctrl.tagName === 'INPUT') { ctrl.disabled = isDimmed && !isMasterOnButton; } if (isDimmed && (ctrl.classList.contains('hue-slider-track') || ctrl.classList.contains('hue-slider-thumb-container'))) { ctrl.style.cursor = 'default'; } else if (!isDimmed && ctrl.classList.contains('hue-slider-thumb-container')) { ctrl.style.cursor = 'pointer'; } else if (!isDimmed && ctrl.classList.contains('hue-slider-track')) { ctrl.style.cursor = 'pointer'; } }); if (domRefs.logoElements && domRefs.logoElements.length > 0) { gsap.killTweensOf(domRefs.logoElements, "opacity"); const targetOpacity = isDimmed ? config.LOGO_DIM_OPACITY : 1; const duration = isDimmed ? 0 : (getCssVarAsNumber('--transition-duration-slow') || 0.3); const ease = isDimmed ? 'none' : 'power1.out'; gsap.to(domRefs.logoElements, { opacity: targetOpacity, duration: duration, ease: ease, overwrite: true }); } }
        function enterSleepMode() { if (state.masterMode === 'sleep') return; state.masterMode = 'sleep'; logMessage(getNextMessage('sleep')); stopCurrentEffect(); if (state.isMouseOverSvg) { handleMouseLeave(); } if (state.logoAnimationTimeline) { state.logoAnimationTimeline.kill(); state.logoAnimationTimeline = null; } setSleepDimmedState(true); if(domRefs.svgElement) domRefs.svgElement.classList.remove('mouse-over'); if (gsap && state.dots.length > 0) { const sleepColor = getComputedStyle(document.documentElement).getPropertyValue('--dot-sleep-color').trim() || '#B3BFCD'; const dotElementsToSleep = state.dots.map(d => d?.el).filter(el => el instanceof SVGElement); if (dotElementsToSleep.length > 0) { gsap.killTweensOf(dotElementsToSleep); gsap.to(dotElementsToSleep, { duration: gsap.utils.random(0.5, 0.8), delay: gsap.utils.random(0, 0.6), ease: 'power2.inOut', attr: { r: 1, cy: geometry.gridCenter.y }, fill: sleepColor, overwrite: true, stagger: 0.002, onStart: (dotIndex) => { const targetElement = dotElementsToSleep[dotIndex]; const dot = state.dots.find(d => d.el === targetElement); if (dot) dot.currentFill = sleepColor; } }); } } }
        function enterActivatedMode() { if (state.masterMode === 'activated') return; state.masterMode = 'activated'; logMessage(getNextMessage('activate')); if (state.logoAnimationTimeline) { state.logoAnimationTimeline.kill(); state.logoAnimationTimeline = null; } setSleepDimmedState(false); applyTheme(state.currentTheme, false); startIntroAnimation(); }

        // ==========================================================================
        // 13. Intro Animation
        // ==========================================================================
        function startIntroAnimation() { const dotElements = state.dots.map(d => d?.el).filter(el => el instanceof SVGElement); const logoElements = domRefs.logoElements; if (state.logoAnimationTimeline) state.logoAnimationTimeline.kill(); if (dotElements.length) gsap.killTweensOf(dotElements); if (logoElements && logoElements.length) gsap.killTweensOf(logoElements); if (logoElements && logoElements.length > 0) { state.logoAnimationTimeline = gsap.timeline(); const flickerOffOpacity = 0.2; const finalOpacity = 1.0; state.logoAnimationTimeline.set(logoElements, { opacity: flickerOffOpacity }); for (let i = 0; i < config.LOGO_FLICKER_COUNT; i++) { const targetOnOpacity = flickerOffOpacity + (finalOpacity - flickerOffOpacity) * (i + 1) / config.LOGO_FLICKER_COUNT; state.logoAnimationTimeline.to(logoElements, { opacity: flickerOffOpacity, duration: config.LOGO_FLICKER_DURATION, ease: 'steps(1)', stagger: 0 }).to(logoElements, { opacity: targetOnOpacity, duration: config.LOGO_FLICKER_DURATION, ease: 'steps(1)', stagger: 0 }); } state.logoAnimationTimeline.set(logoElements, { opacity: finalOpacity }); state.logoAnimationTimeline.to(logoElements, { opacity: config.LOGO_OSCILLATE_OPACITY_MIN, duration: config.LOGO_OSCILLATE_DURATION, ease: 'sine.inOut', repeat: -1, yoyo: true, stagger: 0 }, ">"); } if (!dotElements.length) { startCurrentEffect(); return; } const gridWidth = DATA_BOUNDS.width > 0 ? DATA_BOUNDS.width : 1; const sleepColor = getComputedStyle(document.documentElement).getPropertyValue('--dot-sleep-color').trim() || '#B3BFCD'; const initialDotFill = getComputedStyle(document.documentElement).getPropertyValue('--dot-resting-color').trim() || '#333333'; gsap.set(dotElements, { fill: sleepColor, attr: { cx: (i, t) => state.dots.find(d => d.el === t)?.cx ?? 0, cy: geometry.gridCenter.y, r: 1 } }); state.dots.forEach(d => { if (d) { d.currentFill = sleepColor; }}); gsap.to(dotElements, { duration: config.INTRO_ANIM_DURATION, delay: () => gsap.utils.random(0, config.INTRO_ANIM_RANDOM_DELAY), attr: { cx: (i, t) => state.dots.find(d => d.el === t)?.cx ?? 0, cy: (i, t) => state.dots.find(d => d.el === t)?.cy ?? 0, r: (i, t) => state.dots.find(d => d.el === t)?.initialR ?? dotRadiusInitial }, fill: initialDotFill, stagger: (index, target) => { const dotData = state.dots.find(d => d.el === target); if (!dotData) return 0; const normalizedX = (dotData.cx - DATA_BOUNDS.minX) / gridWidth; return normalizedX * config.INTRO_ANIM_STAGGER * Math.max(1, dotElements.length || 1); }, ease: "power2.out", overwrite: true, onStart: () => { state.dots.forEach(d => { if(d) d.currentFill = initialDotFill; }); }, onComplete: () => { startCurrentEffect(); } }); }

        // ==========================================================================
        // 14. Control Logic & Update Functions
        // ==========================================================================
        function updateDialVisuals(dialEl, indicatorEl, valueEl, angleDeg, formatFn = Math.round) { if (!(dialEl instanceof SVGElement) || !(indicatorEl instanceof SVGGElement) || !(valueEl instanceof HTMLElement)) return NaN; if (typeof angleDeg !== 'number' || isNaN(angleDeg)) angleDeg = config.DIAL_ANGLE_PHYSICAL_MIN; if (typeof formatFn !== 'function') formatFn = Math.round; const dialId = dialEl.dataset.dialId; const dConfig = dialConfigs[dialId]; if (!dConfig) { console.error(`updateDialVisuals: Config not found for dial ID '${dialId}'`); valueEl.textContent = 'Err'; return NaN; } const finalAngle = dConfig.fullRange ? (angleDeg % 360 + 360) % 360 : getClampedAngle(angleDeg); indicatorEl.setAttribute('transform', `rotate(${finalAngle})`); const value = dConfig.fullRange ? angleToValue360(finalAngle, dConfig.displayMin, dConfig.displayMax) : angleToValue(finalAngle, dConfig.displayMin, dConfig.displayMax); valueEl.textContent = formatFn(value); return value; }
        function setActiveEffect(newEffect) { if (!newEffect || (newEffect !== 'wave' && newEffect !== 'sparkle') || (newEffect === state.activeEffect)) return; stopCurrentEffect(); state.dots.forEach(dot => { if(dot) resetDotToInitialVisuals(dot, false); }); state.activeEffect = newEffect; updateEffectDialsVisibility(); startCurrentEffect(); }
        function updateEffectDialsVisibility() { if (!domRefs.waveControls || !domRefs.sparkleControls) { console.error("updateEffectDialsVisibility: Control refs missing."); return; } const showWave = state.activeEffect === 'wave'; try { domRefs.waveControls.forEach(el => { el.style.display = showWave ? 'flex' : 'none'; }); domRefs.sparkleControls.forEach(el => { el.style.display = !showWave ? 'flex' : 'none'; }); } catch (error) { console.error("Error updating dial visibility:", error); } }
        // --- Hue Slider Functions ---
        function calculateHueSliderState(clientX) { if (!state.hueSliderTrackRect || state.hueSliderTrackRect.width <= 0) { if (domRefs.hueTrack) { state.hueSliderTrackRect = domRefs.hueTrack.getBoundingClientRect(); } else { console.warn("calculateHueSliderState: hueTrack ref missing."); return { percent: 50, value: 180 }; } if (!state.hueSliderTrackRect || state.hueSliderTrackRect.width <= 0) { console.warn("calculateHueSliderState: Invalid track bounding rect after recalc."); return { percent: 50, value: 180 }; } } let positionX = clientX - state.hueSliderTrackRect.left; positionX = clamp(positionX, 0, state.hueSliderTrackRect.width); const percent = clamp((positionX / state.hueSliderTrackRect.width) * 100, 0, 100); const value = Math.round((percent / 100) * 360); return { percent, value }; }
        function setHueSliderPosition(percent, value, animate = false) { gsap.killTweensOf(domRefs.hueThumbContainer, "left"); const clickAnimDuration = getCssVarAsNumber('--gsap-slider-click-duration') || 0.08; if (animate) { gsap.to(domRefs.hueThumbContainer, { left: `${percent}%`, duration: clickAnimDuration, ease: 'power1.out' }); } else { gsap.set(domRefs.hueThumbContainer, { left: `${percent}%` }); } if (state.brandHue !== value) { const previousHue = state.brandHue; state.brandHue = value; clearTimeout(state.hueUpdateTimer); updateThemeColors(false); state.hueUpdateTimer = setTimeout(() => { updateThemeColors(true); if (state.masterMode === 'activated' && state.currentTheme === 'saturated') { startCurrentEffect(); } }, config.HUE_UPDATE_DEBOUNCE); } }
        function animateHueIconGrade(targetGrade) { if (!domRefs.thumbIcon) return; const iconAnimDuration = getCssVarAsNumber('--gsap-slider-icon-duration') || 0.1; const iconAnimEase = getCssVarAsNumber('--gsap-slider-icon-ease') || 'power1.out'; gsap.killTweensOf(domRefs.thumbIcon, "--slider-thumb-icon-grad"); gsap.to(domRefs.thumbIcon, { '--slider-thumb-icon-grad': targetGrade, duration: iconAnimDuration, ease: iconAnimEase }); }
        const sliderDragMoveHandler = (event) => { if (!state.isDraggingHueSlider || state.masterMode === 'sleep') return; if (event.type === 'touchmove') event.preventDefault(); const clientX = event.touches ? event.touches[0].clientX : event.clientX; const { percent, value } = calculateHueSliderState(clientX); setHueSliderPosition(percent, value, false); };
        const sliderDragEndHandler = (event) => { if (state.isDraggingHueSlider) { const finalHue = state.brandHue; const initialHue = state.initialHueOnDragStart; logHueChange(initialHue, finalHue); state.isDraggingHueSlider = false; domRefs.hueThumbContainer.style.cursor = 'pointer'; document.body.style.cursor = ''; const containerRect = domRefs.hueSliderContainer.getBoundingClientRect(); let isStillOverContainer = false; if (event.type === 'mouseup' || event.type === 'mouseleave') { isStillOverContainer = event.clientX >= containerRect.left && event.clientX <= containerRect.right && event.clientY >= containerRect.top && event.clientY <= containerRect.bottom; } else if (event.type === 'touchend' && event.changedTouches.length > 0) { const touch = event.changedTouches[0]; isStillOverContainer = touch.clientX >= containerRect.left && touch.clientX <= containerRect.right && touch.clientY >= containerRect.top && touch.clientY <= containerRect.bottom; } if (!isStillOverContainer) { handleHueContainerLeave(event); } else { handleHueContainerMove(event); if (domRefs.hueHoverLine) gsap.to(domRefs.hueHoverLine, { opacity: 1, duration: 0.1, overwrite: true }); } document.removeEventListener('mousemove', sliderDragMoveHandler); document.removeEventListener('touchmove', sliderDragMoveHandler); document.removeEventListener('mouseup', sliderDragEndHandler); document.removeEventListener('touchend', sliderDragEndHandler); document.removeEventListener('mouseleave', sliderDragEndHandler); } };
        function handleHueSliderStart(event) { if (state.masterMode === 'sleep') return; event.preventDefault(); event.stopPropagation(); state.isDraggingHueSlider = true; state.hueSliderTrackRect = domRefs.hueTrack.getBoundingClientRect(); domRefs.hueThumbContainer.style.cursor = 'grabbing'; document.body.style.cursor = 'grabbing'; if (domRefs.hueHoverLine) gsap.to(domRefs.hueHoverLine, { opacity: 0, duration: 0.05, overwrite: true }); const clientX = event.touches ? event.touches[0].clientX : event.clientX; const { percent, value } = calculateHueSliderState(clientX); state.initialHueOnDragStart = state.brandHue; const isTrackClick = event.target === domRefs.hueTrack; setHueSliderPosition(percent, value, isTrackClick); document.addEventListener('mousemove', sliderDragMoveHandler); document.addEventListener('touchmove', sliderDragMoveHandler, { passive: false }); document.addEventListener('mouseup', sliderDragEndHandler); document.addEventListener('touchend', sliderDragEndHandler); document.addEventListener('mouseleave', sliderDragEndHandler); }
        function handleHueContainerHover(event) { if (state.masterMode === 'sleep' || state.isDraggingHueSlider) return; if (domRefs.hueHoverLine) gsap.to(domRefs.hueHoverLine, { opacity: 1, duration: 0.1, overwrite: true }); handleHueContainerMove(event); animateHueIconGrade(200); gsap.to(domRefs.hueTrack, { boxShadow: 'none', '--slider-mask-height-factor': 0, duration: getCssVarAsNumber('--gsap-slider-track-enter-duration') || 0.1, ease: getCssVarAsNumber('--gsap-slider-track-leave-ease') || 'power2.out', overwrite: true }); }
        function handleHueContainerMove(event) { if (state.masterMode === 'sleep' || state.isDraggingHueSlider || !domRefs.hueHoverLine) return; if (!state.hueSliderTrackRect || state.hueSliderTrackRect.width <= 0) { state.hueSliderTrackRect = domRefs.hueTrack.getBoundingClientRect(); } if (!state.hueSliderTrackRect || state.hueSliderTrackRect.width <= 0) return; const clientX = event.touches ? event.touches[0].clientX : event.clientX; let positionX = clientX - state.hueSliderTrackRect.left; positionX = clamp(positionX, 0, state.hueSliderTrackRect.width); gsap.set(domRefs.hueHoverLine, { left: `${positionX}px` }); }
        function handleHueContainerLeave(event) { if (state.masterMode === 'sleep' || state.isDraggingHueSlider) return; if (domRefs.hueHoverLine) gsap.to(domRefs.hueHoverLine, { opacity: 0, duration: 0.1, overwrite: true }); animateHueIconGrade(getCssVarAsNumber('--slider-thumb-icon-grad') || -25); gsap.to(domRefs.hueTrack, { '--slider-mask-height-factor': 1, boxShadow: 'var(--slider-track-inset-shadow)', duration: getCssVarAsNumber('--gsap-slider-track-leave-duration') || 0.1, ease: getCssVarAsNumber('--gsap-slider-track-leave-ease') || 'power2.out', overwrite: true }); }
        function handleHueContainerClick(event) { if (state.masterMode === 'sleep' || state.isDraggingHueSlider) return; if (domRefs.hueThumbContainer && domRefs.hueThumbContainer.contains(event.target)) return; event.stopPropagation(); const initialHue = state.brandHue; const clientX = event.touches ? event.touches[0].clientX : event.clientX; const { percent, value } = calculateHueSliderState(clientX); setHueSliderPosition(percent, value, true); logHueChange(initialHue, value); }
        function initializeHueSlider() { if (!domRefs.hueSliderContainer || !domRefs.hueTrack || !domRefs.hueThumbContainer) { console.error("initializeHueSlider: Missing required DOM elements."); return; } const initialPercent = (state.brandHue / 360) * 100; setHueSliderPosition(initialPercent, state.brandHue, false); domRefs.hueThumbContainer.addEventListener('mousedown', handleHueSliderStart); domRefs.hueThumbContainer.addEventListener('touchstart', handleHueSliderStart, { passive: false }); domRefs.hueTrack.addEventListener('mousedown', handleHueSliderStart); domRefs.hueTrack.addEventListener('touchstart', handleHueSliderStart, { passive: false }); domRefs.hueSliderContainer.addEventListener('mouseenter', handleHueContainerHover); domRefs.hueSliderContainer.addEventListener('mousemove', handleHueContainerMove); domRefs.hueSliderContainer.addEventListener('mouseleave', handleHueContainerLeave); domRefs.hueSliderContainer.addEventListener('click', handleHueContainerClick); const invalidateSliderRect = () => { state.hueSliderTrackRect = null; }; window.addEventListener('resize', invalidateSliderRect); window.addEventListener('orientationchange', invalidateSliderRect); console.log("Hue Slider Initialized."); }


        // ==========================================================================
        // 15. Event Listener Setup
        // ==========================================================================
        function setupEventListeners() {
            domRefs.masterToggle.addEventListener('click', (e) => { const btn = e.target.closest('button'); if (!btn || !btn.dataset.masterMode || btn.classList.contains('active')) return; const newValue = btn.dataset.masterMode; initializeToggle(domRefs.masterToggle, newValue, 'masterMode'); if (newValue === 'sleep') enterSleepMode(); else enterActivatedMode(); });
            domRefs.themeToggle.addEventListener('click', (e) => { if (state.masterMode === 'sleep') return; const btn = e.target.closest('button'); if (!btn || !btn.dataset.theme || btn.classList.contains('active')) return; const newValue = btn.dataset.theme; initializeToggle(domRefs.themeToggle, newValue, 'theme'); logMessage(getNextMessage(themes[newValue]?.messageKey || 'themeLight')); applyTheme(newValue); });
            domRefs.effectTypeToggle.addEventListener('click', (e) => { if (state.masterMode === 'sleep') return; const btn = e.target.closest('button'); if (!btn || !btn.dataset.effectType || btn.classList.contains('active')) return; const newValue = btn.dataset.effectType; initializeToggle(domRefs.effectTypeToggle, newValue, 'effectType'); logMessage(getNextMessage(newValue === 'wave' ? 'effectWave' : 'effectSparkle')); setActiveEffect(newValue); });
            domRefs.hoverTypeToggle.addEventListener('click', (e) => { if (state.masterMode === 'sleep') return; const btn = e.target.closest('button'); if (!btn || !btn.dataset.hoverType || btn.classList.contains('active')) return; const newValue = btn.dataset.hoverType; initializeToggle(domRefs.hoverTypeToggle, newValue, 'hoverType'); logMessage(getNextMessage(newValue === 'attract' ? 'hoverAttract' : 'hoverRepel')); state.activeHoverMode = newValue; });
            domRefs.tapButton.addEventListener('click', () => triggerPopEffect());
            domRefs.jiggleButton.addEventListener('click', triggerShakeEffect);
            domRefs.waveTapButton.addEventListener('click', triggerPulseEffect);
            domRefs.svgElement.addEventListener('mouseenter', handleMouseEnter);
            domRefs.svgElement.addEventListener('mouseleave', handleMouseLeave);
            domRefs.svgElement.addEventListener('touchstart', handleTouchStart, { passive: false });
            domRefs.svgElement.addEventListener('click', handleSvgClick);

            // --- Dial Drag Logic ---
            const dialDragMoveHandler = (e) => { if (state.masterMode === 'sleep' || !state.isDraggingDial || !state.dragDialInfo.element) return; e.preventDefault(); const dial = state.dragDialInfo.element; const dialId = dial.dataset.dialId; const dConfig = dialConfigs[dialId]; if (!dConfig) return; const clientX = e.touches ? e.touches[0].clientX : e.clientX; const clientY = e.touches ? e.touches[0].clientY : e.clientY; const dx = clientX - state.dragDialInfo.center.x; const dy = clientY - state.dragDialInfo.center.y; let rawAngleDeg = (radiansToDegrees(Math.atan2(dy, dx)) + 360) % 360; const finalAngle = dConfig.fullRange ? rawAngleDeg : getClampedAngle(rawAngleDeg); const indicator = domRefs[`indicator_${dialId}`]; const valueSpan = domRefs[`value_${dialId}`]; if (!indicator || !valueSpan) return; const displayedValue = updateDialVisuals(dial, indicator, valueSpan, finalAngle, dConfig.formatFn); if (isNaN(displayedValue)) return; const internalValue = mapRange(displayedValue, dConfig.displayMin, dConfig.displayMax, dConfig.internalMin, dConfig.internalMax); state[dConfig.stateProp] = internalValue; state.dragDialInfo.hitMin = (Math.abs(displayedValue - dConfig.displayMin) < config.EPSILON); state.dragDialInfo.hitMax = (Math.abs(displayedValue - dConfig.displayMax) < config.EPSILON); if (dConfig.needsSvgRecalc) setupSvg(); if (dConfig.needsEffectRestart) startCurrentEffect(); };
            const dialDragEndHandler = (e) => { if (state.isDraggingDial) { const dial = state.dragDialInfo.element; if (dial) { dial.style.cursor = 'pointer'; const dialId = dial.dataset.dialId; const dConfig = dialConfigs[dialId]; const indicator = domRefs[`indicator_${dialId}`]; const valueSpan = domRefs[`value_${dialId}`]; if(dConfig && indicator && valueSpan && state.dragDialInfo.initialValue !== null) { const transformAttr = indicator.getAttribute('transform'); const finalAngleMatch = transformAttr ? transformAttr.match(/rotate\((.*?)\)/) : null; const finalAngle = finalAngleMatch ? parseFloat(finalAngleMatch[1]) : 0; const finalValue = dConfig.fullRange ? angleToValue360(finalAngle, dConfig.displayMin, dConfig.displayMax) : angleToValue(finalAngle, dConfig.displayMin, dConfig.displayMax); const initialValue = state.dragDialInfo.initialValue; const valueChanged = Math.abs(finalValue - initialValue) > config.EPSILON; if (state.dragDialInfo.hitMax && valueChanged) logMessage(getNextMessage('dialMax')); else if (state.dragDialInfo.hitMin && valueChanged) logMessage(getNextMessage('dialMin')); else if (valueChanged) { if (dialId === 'sparkleFreq') logMessage(getNextMessage(finalValue > initialValue ? 'dialIncreaseFreq' : 'dialDecreaseFreq')); else if (dialId === 'waveDirection') { const angle = Math.round(finalValue); if (angle >= 15 && angle <= 75) logMessage(getNextMessage('directionEast')); else if (angle >= 105 && angle <= 165) logMessage(getNextMessage('directionSouth')); else if (angle >= 195 && angle <= 255) logMessage(getNextMessage('directionWest')); else if (angle >= 285 && angle <= 345) logMessage(getNextMessage('directionNorth')); else logMessage(getNextMessage('directionGeneral')); } else logMessage(getNextMessage(finalValue > initialValue ? 'dialIncreaseGeneric' : 'dialDecreaseGeneric')); } } } document.body.style.cursor = ''; state.isDraggingDial = false; state.dragDialInfo = { element: null, center: { x: 0, y: 0 }, initialValue: null, hitMin: false, hitMax: false }; document.removeEventListener('mousemove', dialDragMoveHandler); document.removeEventListener('touchmove', dialDragMoveHandler); document.removeEventListener('mouseup', dialDragEndHandler); document.removeEventListener('touchend', dialDragEndHandler); document.removeEventListener('mouseleave', dialDragEndHandler); } };
            const handleDialStart = (e) => { if (state.masterMode === 'sleep') return; const dial = e.target.closest('.dial-svg'); if (!dial || !dial.dataset.dialId) return; const container = dial.closest('.dial-container'); if (container && container.style.display === 'none') return; e.preventDefault(); const dialId = dial.dataset.dialId; const dConfig = dialConfigs[dialId]; if (!dConfig) return; state.isDraggingDial = true; state.dragDialInfo.element = dial; state.dragDialInfo.hitMin = false; state.dragDialInfo.hitMax = false; const indicator = domRefs[`indicator_${dialId}`]; if(indicator) { const transformAttr = indicator.getAttribute('transform'); const initialAngleMatch = transformAttr ? transformAttr.match(/rotate\((.*?)\)/) : null; const initialAngle = initialAngleMatch ? parseFloat(initialAngleMatch[1]) : 0; state.dragDialInfo.initialValue = dConfig.fullRange ? angleToValue360(initialAngle, dConfig.displayMin, dConfig.displayMax) : angleToValue(initialAngle, dConfig.displayMin, dConfig.displayMax); } else { state.dragDialInfo.initialValue = null; } const rect = dial.getBoundingClientRect(); state.dragDialInfo.center.x = rect.left + rect.width / 2; state.dragDialInfo.center.y = rect.top + rect.height / 2; dial.style.cursor = 'grabbing'; document.body.style.cursor = 'grabbing'; document.addEventListener('mousemove', dialDragMoveHandler); document.addEventListener('touchmove', dialDragMoveHandler, { passive: false }); document.addEventListener('mouseup', dialDragEndHandler); document.addEventListener('touchend', dialDragEndHandler); document.addEventListener('mouseleave', dialDragEndHandler); };
            const controlSectionContainer = document.getElementById('control-section');
            if (controlSectionContainer) { controlSectionContainer.addEventListener('mousedown', handleDialStart); controlSectionContainer.addEventListener('touchstart', handleDialStart, { passive: false }); } else { console.error("Cannot find #control-section to attach dial listener"); }

            window.addEventListener('resize', () => { clearTimeout(state.resizeTimer); state.resizeTimer = setTimeout(() => { setupSvg(); state.hueSliderTrackRect = null; }, 250); });
            window.addEventListener('orientationchange', () => { state.hueSliderTrackRect = null; });
        }

        // ==========================================================================
        // 16. Initialization Execution
        // ==========================================================================
        function main() {
            console.log("Initializing Application (v101 Faster Concurrent Effects)...");
            try {
                if (typeof gsap === 'undefined') throw new Error("GSAP library is not loaded!");
                if (!gsap.plugins.text) throw new Error("GSAP TextPlugin is not loaded!");
                populateDomRefs();
                setupSvg();
                initializeControls();
                initializeHueSlider();
                setupEventListeners();

                setTimeout(() => {
                     if (state.masterMode === 'sleep') {
                         logMessage(getNextMessage('sleep'));
                         setSleepDimmedState(true);
                         initializeToggle(domRefs.masterToggle, state.masterMode, 'masterMode');
                         if (gsap && state.dots.length > 0) {
                             const sleepColor = getComputedStyle(document.documentElement).getPropertyValue('--dot-sleep-color').trim() || '#B3BFCD';
                             const dotElements = state.dots.map(d => d?.el).filter(el => el instanceof SVGElement);
                             gsap.set(dotElements, { attr: { r: 1, cy: geometry.gridCenter.y }, fill: sleepColor });
                             state.dots.forEach(d => { if(d) d.currentFill = sleepColor; });
                         }
                     } else {
                         logMessage(getNextMessage('startup'));
                         setSleepDimmedState(false);
                         initializeToggle(domRefs.masterToggle, state.masterMode, 'masterMode');
                         applyTheme(state.currentTheme, false); // Ensure theme colors set before intro
                         startIntroAnimation();
                     }
                     const consoleColor = getComputedStyle(document.documentElement).getPropertyValue('--console-text-color').trim();
                     if(domRefs.messageBoxContent) domRefs.messageBoxContent.style.color = consoleColor;
                }, 25); // Faster initial delay

            } catch (error) {
                console.error("=== INITIALIZATION FAILED ===", error);
                document.body.innerHTML = `<div style="color: red; border: 0.125rem solid red; padding: 1.25rem; font-family: sans-serif; margin: 1.25rem; background-color: #fee;"><h2>Initialization Error</h2><p>The interactive grid could not be started. Please check the browser console (F12) for more details.</p><p><strong>Error:</strong> ${error.message}</p></div>`;
            }
        }

        // --- Start the application ---
        if (document.readyState === 'loading') { document.addEventListener('DOMContentLoaded', main); }
        else { main(); }

    })(); // End of IIFE
    </script>
</body>
</html>
